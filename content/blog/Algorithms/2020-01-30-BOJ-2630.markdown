---
title: 'BOJ 2630 색종이 만들기'
date: 2020-01-30 01:41:23
category: 'Algorithms'
draft: false
---

## [색종이 만들기](https://www.acmicpc.net/problem/2630)

| 시간 제한 | 메모리 제한 |
| --------- | ----------- |
| 1초       | 128MB       |

### 문제

아래 <그림 1>과 같이 여러개의 정사각형칸들로 이루어진 정사각형 모양의 종이가 주어져 있고,<br>
각 정사각형들은 하얀색으로 칠해져 있거나 파란색으로 칠해져 있다.<br>
주어진 종이를 일정한 규칙에 따라 잘라서 다양한 크기를 가진 정사각형 모양의 하얀색 또는 파란색 색종이를 만들려고 한다.<br>

<img src="./images/2020-01-30-2630/1.png" width="600" height="auto">

전체 종이의 크기가 N×N(N=2k, k는 1 이상 7 이하의 자연수) 이라면 종이를 자르는 규칙은 다음과 같다.<br>
전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로로 중간 부분을 잘라서<br>
<그림 2>의 I, II, III, IV와 같이 똑같은 크기의 네 개의 N/2 × N/2색종이로 나눈다.<br>
나누어진 종이 I, II, III, IV 각각에 대해서도 앞에서와 마찬가지로 모두 같은 색으로 칠해져 있지 않으면 같은 방법으로 똑같은 크기의 네 개의 색종이로 나눈다.<br>
이와 같은 과정을 잘라진 종이가 모두 하얀색 또는 모두 파란색으로 칠해져 있거나,<br>
하나의 정사각형 칸이 되어 더 이상 자를 수 없을 때까지 반복한다.<br>
위와 같은 규칙에 따라 잘랐을 때 <그림 3>은 <그림 1>의 종이를 처음 나눈 후의 상태를,<br>
<그림 4>는 두 번째 나눈 후의 상태를, <그림 5>는 최종적으로 만들어진 다양한 크기의 9장의 하얀색 색종이와 7장의 파란색 색종이를 보여주고 있다.<br>

<img src="./images/2020-01-30-2630/2.png" width="600" height="auto">

입력으로 주어진 종이의 한 변의 길이 N과 각 정사각형칸의 색(하얀색 또는 파란색)이 주어질 때<br>
잘라진 하얀색 색종이와 파란색 색종이의 개수를 구하는 프로그램을 작성하시오.<br>

### 입력

첫째 줄에는 전체 종이의 한 변의 길이 N이 주어져 있다.<br>
N은 2, 4, 8, 16, 32, 64, 128 중 하나이다.<br>
색종이의 각 가로줄의 정사각형칸들의 색이 윗줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다.<br>
하얀색으로 칠해진 칸은 0, 파란색으로 칠해진 칸은 1로 주어지며,<br>
s각 숫자 사이에는 빈칸이 하나씩 있다.<br>

### 출력

첫째 줄에는 잘라진 햐얀색 색종이의 개수를 출력하고,<br>
둘째 줄에는 파란색 색종이의 개수를 출력한다.<br>

### 예제 입력

```python
8
1 1 0 0 0 0 1 1
1 1 0 0 0 0 1 1
0 0 0 0 1 1 0 0
0 0 0 0 1 1 0 0
1 0 0 0 1 1 1 1
0 1 0 0 1 1 1 1
0 0 1 1 1 1 1 1
0 0 1 1 1 1 1 1
```

### 예제 출력

```python
9
7
```

---

## 풀이

문제를 보자마자 **재귀**를 이용한 **분할 정복**으로 구현하면 되겠다 생각했다.<br>
`(0, 0)`부터 시작해 입력으로 받은 `N X N`크기의 2차원 리스트가 모두 같은 색인지 검사하고<br>
모두 같은 색이 아니라면 사각형의 크기를 **반으로 나누어**가며 해결하는 방법으로 구현했다.<br>

### 코드 구현부

```python
from functools import reduce


def cut(paper, x, y, size):
    temp_paper = [paper[i][x:x + size] for i in range(y, y + size)]
    flatten_paper = list(set(reduce(lambda x, y: x + y, temp_paper)))

    if len(flatten_paper) == 1:
        result[flatten_paper[0]] += 1
        return

    cut(paper, x, y, size // 2)
    cut(paper, x + size // 2, y, size // 2)
    cut(paper, x, y + size // 2, size // 2)
    cut(paper, x + size // 2, y + size // 2, size // 2)


N = int(input())
paper = [list(input().split()) for _ in range(N)]
result = {'0': 0, '1': 0}
cut(paper, 0, 0, N)
print(f"{result['0']}\n{result['1']}")
```

### 함수 설명

문제를 해결하기 위하여 `cut(paper, x, y, size)`함수를 구현했다.<br>
함수의 인자는 `paper`, `x`, `y`, `size`를 받게된다.<br>

- `paper` : 2차원 리스트
- `x` : 시작 x 좌표
- `y` : 시작 y 좌표
- `size` : 종이의 크기

함수의 인자의 역할은 위와 같고 함수 내부에서 `temp_paper`라는 값으로 원본 리스트에서<br>
`size`에 맞는 분할된 새로운 2차원 리스트를 만들어 사용한다.<br>

```python
temp_paper = [paper[i][x:x + size] for i in range(y, y + size)]
```

새로운 2차원 리스트가 같은값을 갖는지 확인하기 위해 `reduce`함수와 `set`을 사용했다.<br>
`reduce`함수를 이용해 2차원 리스트를 1차원으로 펴준뒤 `set`으로 중복을 제거했다.<br>

```python
flatten_paper = list(set(reduce(lambda x, y: x + y, temp_paper)))
```

중복을 제거한 `flatten_paper`라는 1차원 리스트의 길이가 1인 경우 모두 같은 색인 경우다.<br>
사각형이 모두 같인 색상인 경우 `result`에 해당하는 색상을 `1`증가시킨 후 재귀를 탈출한다.<br>

```python
if len(flatten_paper) == 1:
    result[flatten_paper[0]] += 1
    return
```

`len(flatten_paper)`가 1이 아닌 경우 4개로 사각형을 쪼개 `cut`함수를 **재귀호출**한다.<br>

```python
cut(paper, x, y, size // 2)
cut(paper, x + size // 2, y, size // 2)
cut(paper, x, y + size // 2, size // 2)
cut(paper, x + size // 2, y + size // 2, size // 2)
```

사각형의 모든 부분을 탐색한 후 `cut`함수가 종료되면 `result`딕셔너리에담겨있는 값을<br>
`python3.6`부터 사용할 수 있는 `f-string`을 사용해 출력해주었다.<br>
다른 언어에 비해 **문자열 포맷팅**이 비교적 복잡했던 파이썬이였는데 `f-string`을 알고난 후<br>
다른 언어와 마찬가지로 문자열을 포맷팅 하는 것이 많이 수월해진 것 같다.<br>

```python
print(f"{result['0']}\n{result['1']}")
```

### 결과

비교적 어렵지 않지만 재밌게 풀 수 있었던 문제였다.<br>
졸린 시점에 리프레쉬하기 위해 푼 문제치고는 한번의 시도만에 빠르게 해결할 수 있었던 문제다.<br>

<img src="./images/2020-01-30-2630/3.PNG" width="500" height="auto">

문제의 설명을 보니 **정보올림피아드 중등부 문제**라고 한다.<br>
중학생 대회의 1번 문제 조차 나에게는 그렇게 쉽지 많은 않았던 것 같다.<br>
문제를 스스로 해결한 것 외에도 더 열심히 개발 공부를 해야겠다는 **동기 부여**가 될 수 있었다.<br>
&#9989; 코드는 [[여기]](https://github.com/alstn2468/BaekJoon_Online_Judge/blob/master/2600~2699/2630.py)에서 확인할 수 있다.
