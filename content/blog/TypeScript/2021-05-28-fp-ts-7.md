---
title: 'fp-ts로 Typescript 함수형 프로그래밍 시작하기 7 (Applicative)'
date: 2021-05-28 00:01:04
category: 'TypeScript'
draft: true
---

본 포스트는 fp-ts 공식 문서의 [Learning Resources](https://gcanti.github.io/fp-ts/learning-resources/)에 있는 Getting Started에서 소개하는 문서들을 번역하며 학습한 문서입니다. 원본 문서는 [링크](https://dev.to/gcanti/getting-started-with-fp-ts-applicative-1kb3)에서 확인할 수 있으며 작성한 코드들은 [여기](https://github.com/alstn2468/getting-started-fp-ts/tree/main/src/7_applicative)에서 확인할 수 있습니다.

## fp-ts 시작하기 (Applicative)

[지난 포스트](https://alstn2468.github.io/TypeScript/2021-05-01-fp-ts-5/)에서 우리는 `F`가 Functor 인스턴스를 허용하는 경우 `g`를 `lift(g)` 함수로 `lift(g): (fb: F<B>) => F<C>`와 같이 들어 올림으로써 순수한 프로그램 `g: (b: B) => C`로 이펙트 있는 프로그램 `f: (a: A) => F<B>`를 조합할 수 있음을 보았습니다.

| 프로그램 f  |  프로그램 g   |     조합      |
| :---------: | :-----------: | :-----------: |
|   순수한    |    순수한     |    `g ∘ f`    |
| 이펙트 있는 | 순수한 (단항) | `lift(g) ∘ f` |

그러나 `g`는 단항이어야 합니다. 즉, 하나의 인자만 입력으로 받아야 합니다. `g`가 두 개의 인자를 받아야 한다면 어떻게 하면 될까요? 그래도 Functor 인스턴스만 사용해서 `g`를 들어 올릴 수 있을까요?

## 커링

우선 우리는 두 개의 인자를 받아들이고 타입 `B`와 `C`(튜플을 사용할 수 있다.)를 받아들이고 `D` 타입 값을 반환하는 함수를 모델링해야 합니다.

```typescript
g: (args: [B, C]) => D;
```

우리는 **커링**이라는 기술을 사용하여 `g`를 다시 작성할 수 있습니다.

> 커링은 여러 인자를 사용하는 함수의 평가를 **각각 단일 인자**가 있는 일련의 함수를 평가하는 것으로 변환하는 기술입니다. 예를 들어, 두 개의 인수 (`B`에서 하나, `C`에서 하나)를 받고 커링을 통해 `D`에서 출력을 생성하는 함수는 `C`에서 단일 인자를 가져와 `B`에서 `C`로 출력 함수를 생성하는 함수로 변환됩니다.

`g`를 아래와 같이 다시 작성할 수 있습니다.

```typescript
g: (b: B) => (c: C) => D;
```

우리가 원하는 것은 들어 올리는 작업입니다. 이전 `lift`와 구별하기 위해 `liftA2`라고 부르며 아래 시그니처를 갖는 함수를 반환합니다.

```typescript
liftA2(g): (fb: F<B>) => (fc: F<C>) => F<D>
```

`g`는 이제 단항이므로 Functor 인스턴스와 이전의 `lift`를 사용할 수 있습니다.

```typescript
lift(g): (fb: F<B>) => F<(c: C) => D>
```

하지만 이제 막혔습니다. `F<(c: C) => D>` 값을 함수 `(fc: F<C>) => F<D>`로 **풀 수 있는** Functor 인스턴스에 대한 정상적인 기능이 없습니다.

## Apply

따라서 이런 푸는 작업을 갖는 새로운 추상화 `ap`라 불리는 `Apply`를 소개하겠습니다.

```typescript
interface Apply<F> extends Functor<F> {
  ap: <C, D>(fcd: HKT<F, (c: C) => D>, fc: HKT<F, C>) => HKT<F, D>;
}
```

`ap` 함수는 기본적으로 인자를 재배열하여 묶인 것을 풉니다.

```typescript
unpack: <C, D>(fcd: HKT<F, (c: C) => D>) => ((fc: HKT<F, C>) => HKT<F, D>)
ap:     <C, D>(fcd: HKT<F, (c: C) => D>, fc: HKT<F, C>) => HKT<F, D>
```

따라서 `ap`는 `unpack`에서 파생될 수 있으며 반대의 경우도 마찬가지로 가능합니다.

> 참고: `HKT` 타입은 제네릭 타입 생성자를 나타내는 fp-ts의 방식입니다. ([Lightweight 고급 다형성](https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf) 논문에서 제안 된 기술), `HKT<F, X>`를 보면 타입 `X`에 적용된 타입 생성자 `F`를 생각할 수 있습니다. (예: F<X>)

## Applicative
