---
title: 'fp-ts로 Typescript 함수형 프로그래밍 시작하기 10 (IO)'
date: 2021-06-19 00:01:04
category: 'TypeScript'
draft: true
---

본 포스트는 fp-ts 공식 문서의 [Learning Resources](https://gcanti.github.io/fp-ts/learning-resources/)에 있는 Getting Started에서 소개하는 문서들을 번역하며 학습한 문서입니다. 원본 문서는 [링크](https://dev.to/gcanti/getting-started-with-fp-ts-io-36p6)에서 확인할 수 있으며 작성한 코드들은 [여기](https://github.com/alstn2468/getting-started-fp-ts/tree/main/src/getting_started_series/10_io)에서 확인할 수 있습니다.

## fp-ts 시작하기 (IO)

`fp-ts`에서 동기적인 이펙트 있는 계산은 기본적으로 `() => A` 시그니처를 갖는 **썽크**인 `IO` 타입으로 표현합니다.

```typescript
interface IO<A> {
  (): A;
}
```

> 참고: `IO`는 **절대 실패하지 않는** 계산을 표현합니다.

이러한 계산의 예시는 아래와 같습니다.

- `localStorage`에 읽기 / 쓰기
- 현재 시간을 얻기
- 콘솔에 쓰기
- 임의의 숫자를 얻기

### 예시 (`localStorage`에 읽기 / 쓰기)

```typescript
import type { Option } from 'fp-ts/lib/Option';
import { fromNullable } from 'fp-ts/lib/Option';

const getItem = (key: string): IO<Option<string>> => () =>
  fromNullable(localStorage.getItem(key));

const setItem = (key: string, value: string): IO<void> => () =>
  localStorage.setItem(key, value);
```

### 예시 (현재 시간을 얻기)

```typescript
const now: IO<number> = () => new Date().getTime();
```

### 예시 (콘솔에 쓰기)

```typescript
const log = (s: unknown): IO<void> => () => console.log(s);
```

### 예시 (임의의 숫자를 얻기)

```typescript
const random: IO<number> = () => Math.random();
```

`IO` 타입은 [Monad](https://alstn2468.github.io/TypeScript/2021-06-05-fp-ts-8/) 인스턴스를 허용하므로 `map`을 사용할 수 있습니다.

> 원문에서는 `io.map`을 사용하라고 작성되어 있지만, 최신 버전의 fp-ts에서는 deprecated 되어 있으며 [`IO/map`](https://gcanti.github.io/fp-ts/modules/IO.ts.html#map)을 사용하면 됩니다.

```typescript
import { map } from 'fp-ts/lib/IO';

/** 무작위의 boolean을 반환한다. */
const randomBool: IO<boolean> = map(n => n < 0.5)(random);
```

또한 `chain` 연산을 사용할 수 있습니다.

> 원문에서는 `io.chain`을 사용하라고 작성되어 있지만, 최신 버전의 fp-ts에서는 deprecated 되어 있으며 [`IO/chain`](https://gcanti.github.io/fp-ts/modules/IO.ts.html#chain)을 사용하면 됩니다.

```typescript
import { chain } from 'fp-ts/lib/IO';

/** 무작위의 boolean을 콘솔에 출력한다. */
const program: IO<void> = chain(log)(randomBool);

program();
```

> 참고: `program()`을 호출할 때까지 **아무 일도 일어나지 않습니다**.

그 이유는 `program`은 이펙트 있는 계산을 **표현**하는 **값**이기 때문에, 어떤 사이드 이펙트를 실행하기 위해서는 "`IO` 액션을 실행"해야 하기 때문입니다.

`IO` 액션은 값일 뿐이므로 [Monoid](https://alstn2468.github.io/TypeScript/2021-04-29-fp-ts-4/)와 같은 유용한 추상화를 사용하여 처리할 수 있습니다.

### 예시 (Dungeons and Dragons)

```typescript
import type { IO } from 'fp-ts/lib/IO';
import type { Monoid } from 'fp-ts/lib/Monoid';
import { log } from 'fp-ts/lib/Console';
import { chain } from 'fp-ts/lib/IO';
import { concatAll } from 'fp-ts/lib/Monoid';
import { MonoidSum } from 'fp-ts/lib/number';
import { randomInt } from 'fp-ts/lib/Random';
import { getApplicativeMonoid } from 'fp-ts/lib/Applicative';

type Die = IO<number>;

const monoidDie: Monoid<Die> = getApplicativeMonoid(Applicative)(MonoidSum);

/** 주사위를 굴린 결과의 합을 반환합니다. */
const roll: (dice: Array<Die>) => IO<number> = concatAll(monoidDie);

const D4: Die = randomInt(1, 4);
const D10: Die = randomInt(1, 10);
const D20: Die = randomInt(1, 20);

const dice = [D4, D10, D20];

chain((result) => log(`Result is: ${result}`))(roll(dice))();
/*
Result is: 11
*/
```

또는 유용한 [콤비네이터](https://dev.to/gcanti/functional-design-combinators-14pn)를 정의할 수 있습니다.

```typescript
/** 디버깅을 위해 콘솔에 값을 기록한다. */
const withLogging = <A>(action: IO<A>): IO<A> =>
  chain<A, A>(a => map(() => a)(log(`Value is: ${a}`)))(action);

chain(result => log(`Result is: ${result}`))(roll(dice.map(withLogging)))();
/*
Value is: 4
Value is: 2
Value is: 13
Result is: 19
*/
```

## 에러 처리

## Lifiting
