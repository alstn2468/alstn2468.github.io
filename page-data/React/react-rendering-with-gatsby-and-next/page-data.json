{"componentChunkName":"component---src-templates-blog-post-js","path":"/React/react-rendering-with-gatsby-and-next","result":{"data":{"site":{"siteMetadata":{"title":"Minsu's Dev Log","author":"Minsu Kim","siteUrl":"https://alstn2468.github.io","comment":{"disqusShortName":"","utterances":"alstn2468/alstn2468.github.io"},"sponsor":{"buyMeACoffeeId":"eMLdEwU"}}},"markdownRemark":{"id":"998f0847-208f-5ecd-b3ee-3794cd778e07","excerpt":"React의 기본적인 렌더링 방식 React는 기본적으로 단일 페이지 애플리케이션(Single Page Application, SPA)으로 흔하게 사용됩니다.\nSPA가 동작하기 위해서는 처음 요청을 보냈을 때 앱에 필요한 스크립트들을 전부 다운로드해야 합니다.\n이 SPA 앱은 라우터(router)를 이용해 URL을 변경하며 페이지 이동을 자연스럽게 할 수 있습니다. 이처럼 SPA…","html":"<h2 id=\"react의-기본적인-렌더링-방식\" style=\"position:relative;\"><a href=\"#react%EC%9D%98-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%B0%A9%EC%8B%9D\" aria-label=\"react의 기본적인 렌더링 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React의 기본적인 렌더링 방식</h2>\n<p>React는 기본적으로 단일 페이지 애플리케이션(<strong>S</strong>ingle <strong>P</strong>age <strong>A</strong>pplication, SPA)으로 흔하게 사용됩니다.\nSPA가 동작하기 위해서는 처음 요청을 보냈을 때 앱에 필요한 스크립트들을 전부 다운로드해야 합니다.\n이 SPA 앱은 라우터(router)를 이용해 URL을 변경하며 페이지 이동을 자연스럽게 할 수 있습니다.</p>\n<p>이처럼 SPA 개념이 등장하면서 하나의 앱에서 여러 페이지를 보여주는 개념이 같이 생겨났는데 이를 클라이언트 사이드 렌더링(<strong>C</strong>lient <strong>S</strong>ide <strong>R</strong>endering, CSR)이라고 합니다.</p>\n<h3 id=\"client-side-rendering-csr\" style=\"position:relative;\"><a href=\"#client-side-rendering-csr\" aria-label=\"client side rendering csr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>C</strong>lient <strong>S</strong>ide <strong>R</strong>endering (CSR)</h3>\n<p>CSR 방식은 구현된 코드들을 번들링 도구를 통해 하나 또는 여러 개의 JavaScript 파일로 묶어 사용자에게 한 번에 전달합니다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 49.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABTElEQVQoz5VSy4rCQBDM//+O4EFyERQ1iqKHRAXjMz7zUEOikmjtVkNnI3hwBzqZnumpqaoeA7/j9Xrhv6N8pjw3+MnzXJLJZALTNDEYDFCv1yV6vR4qlQr6/T4ajQZGoxGGwyHa7bbU7vf7N1CjjH6/3xGGIYIgwPV6xfF4xPl8xuFwgO/7OJ1OsrbdbmU/iiKkafoOyA8ZXS4XWdR4Pp9fy2ftG+B0OhV5juOInGazCcuy8Hg88MljzT+tG2W5i8UCtm2LJMqkxFqthizLPgaZeZ6H9XqN3W7356HKo/RutyuMCbparaSYTHnh7XaT0Dn/nU4HrVZLmlcAavCW2WwmDeDgIYLFcSxNSJKkCOYEdF0X1WpVFBUeqhcs5DMgCD2dz+fYbDZYLpcYj8fClgDMaQ/31K7CQ2Wn3dLg0ymzV2v4ZrWrukYCatsPTxf7ilM0TboAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1 client side rendering\" title=\"1 client side rendering\" src=\"/static/3afe142108998a2d8e8cd02fd6964c9b/0a47e/1-client-side-rendering.png\" srcset=\"/static/3afe142108998a2d8e8cd02fd6964c9b/8a4e8/1-client-side-rendering.png 150w,\n/static/3afe142108998a2d8e8cd02fd6964c9b/5a46d/1-client-side-rendering.png 300w,\n/static/3afe142108998a2d8e8cd02fd6964c9b/0a47e/1-client-side-rendering.png 600w,\n/static/3afe142108998a2d8e8cd02fd6964c9b/1cfc2/1-client-side-rendering.png 900w,\n/static/3afe142108998a2d8e8cd02fd6964c9b/c1b63/1-client-side-rendering.png 1200w,\n/static/3afe142108998a2d8e8cd02fd6964c9b/2215f/1-client-side-rendering.png 1548w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<p>위의 그림과 같이 HTML을 응답으로 전달받으면, 브라우저는 HTML에서 필요로 하는 JavaScript 파일을 다운로드합니다. JavaScript 파일이 다운로드되면 React는 컴포넌트 트리를 렌더링하고 DOM 노드들을 생성합니다.</p>\n<p>React에서 기본적으로 제공하는 보일러 플레이트인 <code class=\"language-text\">create-react-app</code>를 보면 알 수 있듯이 <a href=\"https://github.com/facebook/create-react-app/blob/main/packages/cra-template/template/public/index.html\">기본 제공되는 HTML 파일</a>은 의미 있는 정보를 포함하고 있지 않습니다.</p>\n<p>사용자들은 모든 스크립트가 다운로드가 끝나고 실행이 끝나기 전까지는 실제 필요한 정보들을 볼 수 없다는 것을 의미합니다. 이것은 흔히 CSR 방식의 단점으로 꼽히는 <strong>SEO 문제</strong>로 이어집니다. SEO를 수집하기 위한 웹 크롤러들은 서버에서 응답으로 전달하는 HTML은 쉽게 읽을 수 있지만, 실제 페이지의 의미 있는 정보는 스크립트가 모두 실행된 이후에 설정될 수 있기 때문입니다.</p>\n<p>또한 React는 컴포넌트가 그려지는 시점에 서버 API를 통해 데이터를 가져오기 때문에 초기 페이지 로딩이 오래걸릴 수 있습니다.</p>\n<p>하지만 CSR 방식이 단점만 있는 것은 아닙니다. CSR 방식으로 구현된 앱 어플리케이션의 <strong>번들링 된 결과물은 모두 정적 파일</strong>이기 때문에 콘텐츠 전송 네트워크(<strong>C</strong>ontent <strong>D</strong>elivery <strong>N</strong>etwork, CDN)를 통해 사용자에게 제공할 수 있습니다.</p>\n<p>또한 모든 렌더링을 사용자의 브라우저에서 수행하기 때문에 <strong>페이지 전환이 자연스럽다는</strong> 장점 또한 존재합니다.</p>\n<p>CSR 방식의 장단점을 요약하면 아래와 같습니다.</p>\n<p><strong>장점</strong></p>\n<ul>\n<li>모든 렌더링을 사용자 브라우저에서 수행하므로 페이지 전환이 자연스럽습니다.</li>\n<li>번들링 된 결과물은 모두 정적 파일이므로 CDN을 통해 쉽게 제공할 수 있습니다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>모든 스크립트가 다운로드되고 실행되기 전까지 필요한 정보를 볼 수 없습니다.</li>\n<li>SEO에 문제가 있을 수 있습니다.</li>\n<li>컴포넌트가 그려지는 시점에 API를 통해 데이터를 가져와 초기 로딩이 길 수 있습니다.</li>\n</ul>\n<br/>\n이런 CSR 방식의 단점들을 보완하기 위해 여러 가지 렌더링 방식들이 생겨났습니다. React를 이용하는 대표적인 프레임워크인 GatsbyJS와 NextJS를 통해 다양한 렌더링 방식들을 살펴보겠습니다.\n<h2 id=\"gatsbyjs의-렌더링-방식\" style=\"position:relative;\"><a href=\"#gatsbyjs%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%B0%A9%EC%8B%9D\" aria-label=\"gatsbyjs의 렌더링 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GatsbyJS의 렌더링 방식</h2>\n<p>GatsbyJS는 React 기반의 웹 애플리케이션 생성 프레임워크며 대표적으로 정적 사이트 생성(<strong>S</strong>tatic <strong>S</strong>ite <strong>G</strong>eneration, SSG) 방식을 사용했습니다. 최근 GatsbyJS v4가 공개되었고 v4부터는 SSG 방식 외에도 서버 사이드 렌더링(<strong>S</strong>erver <strong>S</strong>ide <strong>R</strong>endering, SSR)과 지연된 정적 사이트 생성(<strong>D</strong>eferred <strong>S</strong>tatic <strong>G</strong>eneration, DSG) 방식 또한 지원하게 되었습니다.</p>\n<p>이번 섹션에서는 GatsbyJS에서의 SSG, SSR, DSG의 동작 방식과 장단점, 그리고 이 렌더링 방식이 어떻게 CSR의 단점을 보완할 수 있는지 알아보겠습니다.</p>\n<h3 id=\"static-site-generation-ssg\" style=\"position:relative;\"><a href=\"#static-site-generation-ssg\" aria-label=\"static site generation ssg permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>S</strong>tatic <strong>S</strong>ite <strong>G</strong>eneration (SSG)</h3>\n<p>CSR 방식의 애플리케이션의 라우팅은 JavaScript를 이용해 필요한 콘텐츠를 다시 그려주는 방식이지만 SSG 방식의 애플리케이션은 <strong>빌드 과정에서 각 페이지의 HTML을 생성</strong>해 페이지를 이동하는 방식입니다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 49.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABPUlEQVQoz6WSW6uCQBSF+/9/JyQffLQSUjGSegmp8AKZl+ye1jpnbRhROL2cBjYzs539zdprHOB3vN9vfDO69QO1ybIMw+EQpmliPp9D0zTYtg1d1zGbzWBZFsbjMXzfh+u6MAwD0+m0BSrOQJGfzyf2+73E8XhEmqbI8xyHw0Fy3HNdFAXKspSZIhSoBRLUNM2/2329XhItMAgCaamqKlHGW6nm8Xj0ilRbKpj7y0vx8Hw+IwxDLBYLLJdLRFGE+/0Ox3Gw3W4/qrter9hsNtjtdrhcLv1HieNYTF+tVgIniGv6SDiLWaSCOZ7jA3meJ+sekIXr9VpAbJe+8ltd11KsLGCevrNlgkejkbw4z/SAnJMkwel0EggPUxXjdrvJfjKZiCVsk78P8+qCnofKeKog7NOgLVTSVcm5C/wBVSv+yS/Lft8AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2 static site generation\" title=\"2 static site generation\" src=\"/static/c44f4083dd6cfeb0491986f984564513/0a47e/2-static-site-generation.png\" srcset=\"/static/c44f4083dd6cfeb0491986f984564513/8a4e8/2-static-site-generation.png 150w,\n/static/c44f4083dd6cfeb0491986f984564513/5a46d/2-static-site-generation.png 300w,\n/static/c44f4083dd6cfeb0491986f984564513/0a47e/2-static-site-generation.png 600w,\n/static/c44f4083dd6cfeb0491986f984564513/1cfc2/2-static-site-generation.png 900w,\n/static/c44f4083dd6cfeb0491986f984564513/c1b63/2-static-site-generation.png 1200w,\n/static/c44f4083dd6cfeb0491986f984564513/2b608/2-static-site-generation.png 1540w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<p>SSG 방식은 애플리케이션의 <strong>모든 페이지를 미리 렌더링</strong>해 사용자의 요청에 맞는 HTML을 응답합니다. 이런 SSG 방식은 데이터베이스나 서버가 거의 필요 없는 구조로 애플리케이션을 구성할 수 있습니다. 또한 SSG 방식의 빌드 결과물은 CSR 방식과 같은 정적 파일이므로 CSR 방식의 장점인 <strong>CDN 호스팅 또한 가능</strong>합니다.</p>\n<p>GatsbyJS의 SSG 방식으로 빌드된 HTML에는 JavaScript가 실행되지 않아도 의미있는 정보가 포함될 수 있습니다. 따라서 CSR 방식의 단점이었던 <strong>SEO 문제 또한 보완</strong>이 가능합니다. 애플리케이션에 필요한 데이터들은 모두 빌드 시점에 HTML로 생성되기 때문에 웹 크롤러들이 문제없이 HTML을 읽을 수 있습니다.</p>\n<p>하지만 SSG 방식도 단점이 존재합니다. SSG 방식으로 구현된 애플리케이션에 새로운 페이지가 필요한 경우 <strong>애플리케이션을 새로 빌드</strong>해야하며 <strong>빌드 시간에 데이터를 가져와 HTML</strong>을 생성하므로 CSR 방식에 비하여 <strong>빌드 시간이 오래</strong> 걸립니다.</p>\n<p>위의 내용으로 미루어 보았을 때 SSG 방식은 CSR 방식의 단점을 보완하지만 <strong>애플리케이션의 내용이 자주 변하는 사이트에는 적합하지 않은</strong> 방식입니다.</p>\n<p>SSG 방식의 장단점을 요약하면 아래와 같습니다.</p>\n<p><strong>장점</strong></p>\n<ul>\n<li>번들링 된 결과물은 모두 정적 파일이므로 CDN을 통해 쉽게 제공할 수 있습니다.</li>\n<li>브라우저에서 스크립트가 실행되지 않아도 콘텐츠가 그려질 수 있습니다.</li>\n<li>CSR 방식의 단점인 SEO 문제를 보완할 수 있습니다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>새로운 페이지가 필요한 경우 애플리케이션을 새로 빌드해야 합니다.</li>\n<li>CSR 방식에 비해 빌드 시간이 오래 걸립니다.</li>\n</ul>\n<br/>\n<p><strong>GatsbyJS의 라우팅 최적화</strong></p>\n<p>GatsbyJS는 애플리케이션 빌드가 완료되면 모든 페이지가 각각의 HTML로 만들어집니다. SSG 방식으로 빌드된 HTML 문서 간의 라우팅 과정에서 사용자 경험을 위해 페이지 데이터들을 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Prefetch\">prefetch</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preload\">preload</a>하는 방식을 추가로 사용합니다.</p>\n<blockquote>\n<p>GatsbyJS의 라우팅을 위한 Link API는 <a href=\"https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-link/\">여기</a>에서 자세히 확인할 수 있습니다.</p>\n</blockquote>\n<figure>\n  <img src=\"/7ed797d9929be9f17242e5ddbbe1966c/3-gatsby-routing-optimization.gif\">\n  <figcaption>\n    GatsbyJS가 라우팅 될 페이지의 데이터를 미리 가져오는 모습\n  </figcaption>\n</figure>\n<br/>\n<p>다음으로는 GatsbyJS v4에 새롭게 추가된 서버 사이드 렌더링(<strong>S</strong>erver <strong>S</strong>ide <strong>R</strong>endering, SSR) 방식에 대해서 살펴보겠습니다.</p>\n<h3 id=\"server-side-rendering-ssr\" style=\"position:relative;\"><a href=\"#server-side-rendering-ssr\" aria-label=\"server side rendering ssr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>S</strong>erver <strong>S</strong>ide <strong>R</strong>endering (SSR)</h3>\n<p>CSR 방식은 브라우저를 이용해 HTML을 생성하는 방식이지만 SSR 방식은 사용자의 요청에 따라 <strong>서버에서 JavaScript를 실행해 HTML을 생성하는 방식</strong>입니다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 49.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABRUlEQVQoz61SyY6CUBD0/7+Fq0fEAxcXRCLGuIERd4wKCi4sNamewYGDl8l0Ury1q+tVU8NP5HmOv0Y5t8ZPlmWy6PV60HUd4/EYhmFA0zT0+300Gg1YloVOpyN3eN5ut6GqKjabTYW0VmY/Ho9YLpfY7/fwfR+e52G32wnW67Vgu91isVjIHe5fr9c3ISEKn88n/iuEkPLn87lUu1wuOBwOMhZBS8pgRFEk9txuN5zPZ3nd/X7/JkySBEEQYDabiVfT6VSezL1ms/lRzel0Eo8paDgc4vV6VT0cDAYwTVPU0i/HcQSPx0Oqx3EsKOYU0u12Ua/XYdv2b1MKrFYrTCYTMZskTOJIK8IwFKLymvPRaARFUST37WGhkgQkY+U0TStgsOutVks67bqudLrcVOlyoY7BRJJ9+smpjA3gebkolRbN+gIU6vyJE1pshwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4 server side rendering\" title=\"4 server side rendering\" src=\"/static/206962ade31994d7bb5d7cad8d6d8632/0a47e/4-server-side-rendering.png\" srcset=\"/static/206962ade31994d7bb5d7cad8d6d8632/8a4e8/4-server-side-rendering.png 150w,\n/static/206962ade31994d7bb5d7cad8d6d8632/5a46d/4-server-side-rendering.png 300w,\n/static/206962ade31994d7bb5d7cad8d6d8632/0a47e/4-server-side-rendering.png 600w,\n/static/206962ade31994d7bb5d7cad8d6d8632/1cfc2/4-server-side-rendering.png 900w,\n/static/206962ade31994d7bb5d7cad8d6d8632/c1b63/4-server-side-rendering.png 1200w,\n/static/206962ade31994d7bb5d7cad8d6d8632/dca52/4-server-side-rendering.png 1550w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<p>JavaScript를 실행한 SSR 방식은 웹에 자주 사용되던 PHP나 JSP/Servlet과 비슷하게 동작합니다. 다른 점은 <strong>GatsbyJS의 SSR의 런타임은 Node.js가 사용</strong>됩니다.</p>\n<p>SSR 방식은 브라우저에서 실행될 JavaScript를 서버에서 실행해 HTML을 생성하기 때문에 CSR 방식보다 <strong>초기 페이지 렌더링이 늦어</strong>질 수 있지만, CSR 방식에 비하여 사용자에게 보여주는 <strong>콘텐츠가 로딩되는 시점은 빨라</strong>질 수 있으며, HTML을 서버에서 생성해서 응답하기 때문에 CSR 방식의 단점인 <strong>SEO 문제가 해결</strong>될 수 있습니다.</p>\n<p>SSR 방식은 CSR 방식과 다르게 <strong>CDN을 이용한 정적 파일 제공이 불가능</strong>하며 Node.js 환경에서 실행되기 때문에 <strong>브라우저 API를 사용할 때 주의</strong>해야 합니다. Node.js 환경에서는 <code class=\"language-text\">window</code>나 <code class=\"language-text\">document</code>와 같은 브라우저 객체에 접근할 수 없으므로 관련 코드를 작성할 때 유의해야 합니다.</p>\n<ul>\n<li><code class=\"language-text\">typeof</code> 키워드를 이용해 예외 처리를 하는 예시</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> window <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 브라우저에서 실행되어야 하는 코드</span>\n  window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'scroll'</span><span class=\"token punctuation\">,</span> onScroll<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">useEffect</code>를 이용해 예외 처리를 하는 예시</li>\n</ul>\n<p>React의 <code class=\"language-text\">useEffect</code> 훅은 컴포넌트가 마운트 되는 시점에 호출되기 때문에 브라우저 환경에서 실행되므로 <code class=\"language-text\">window</code>나 <code class=\"language-text\">docuemnt</code> 같은 브라우저 객체에 접근할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 브라우저에서 실행되어야 하는 코드</span>\n  window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'scroll'</span><span class=\"token punctuation\">,</span> onScroll<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>SSR 방식의 장단점을 요약하면 아래와 같습니다.</p>\n<p><strong>장점</strong></p>\n<ul>\n<li>전체적인 콘텐츠 로딩이 CSR 방식에 비해 빨라질 수 있습니다.</li>\n<li>CSR 방식의 단점인 SEO 문제를 보완할 수 있습니다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>서버에서 JavaScript를 실행해야 하므로 초기 페이지 렌더링이 늦어질 수 있습니다.</li>\n<li>Node.js 런타임에서 실행되므로 브라우저 API를 사용할 때 주의해야 합니다.</li>\n<li>CDN을 이용한 제공이 불가능하고 CSR 방식에 비하여 안정성이 떨어질 수 있습니다.</li>\n</ul>\n<br/>\n<p><strong>GatsbyJS의 SSR</strong></p>\n<p>GatsbyJS의 SSR 방식은 v4부터 새롭게 추가되었습니다. GatsbyJS는 앞에서 소개한 SSG 방식이나 뒤에서 소개하게 될 DSG(<strong>D</strong>eferred <strong>S</strong>tatic <strong>G</strong>eneration) 방식을 사용하는 것을 권장하지만 사용자 인증이나 A/B 테스트, 위치나 사용자 데이터 기반으로 구성되어야 하는 사례가 있을 경우를 위해 SSR 방식 또한 제공합니다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 64.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAwAF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAgH/2gAMAwEAAhADEAAAAdwnBF6jf//EABcQAQEBAQAAAAAAAAAAAAAAAAEDABH/2gAIAQEAAQUC5qVJA9NSRTBw/8QAFxEAAwEAAAAAAAAAAAAAAAAAARARIf/aAAgBAwEBPwE2Yv/EABcRAAMBAAAAAAAAAAAAAAAAAAEQESH/2gAIAQIBAT8BEur/xAAYEAADAQEAAAAAAAAAAAAAAAAAARFBEP/aAAgBAQAGPwLRVMvFcIf/xAAZEAEBAQEBAQAAAAAAAAAAAAABEQBRYTH/2gAIAQEAAT8hi/RfdYBcAdFyYcJPGgcE3//aAAwDAQACAAMAAAAQMP8A/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAERIUH/2gAIAQMBAT8QubFJ/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAFx/9oACAECAQE/EMhX/8QAHBABAAMAAwEBAAAAAAAAAAAAAQARITFBYVFx/9oACAEBAAE/EEFsWH1OUZ8JeQ3YBR9lFVlPXcMn2rJz+kI7QBfk/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5 server side rendering\" title=\"5 server side rendering\" src=\"/static/7c6eea7162dc472bb260180809aba437/b4294/5-server-side-rendering.jpg\" srcset=\"/static/7c6eea7162dc472bb260180809aba437/75985/5-server-side-rendering.jpg 150w,\n/static/7c6eea7162dc472bb260180809aba437/f93b5/5-server-side-rendering.jpg 300w,\n/static/7c6eea7162dc472bb260180809aba437/b4294/5-server-side-rendering.jpg 600w,\n/static/7c6eea7162dc472bb260180809aba437/8e1fc/5-server-side-rendering.jpg 900w,\n/static/7c6eea7162dc472bb260180809aba437/e5166/5-server-side-rendering.jpg 1200w,\n/static/7c6eea7162dc472bb260180809aba437/d165a/5-server-side-rendering.jpg 1400w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<p>GatsbyJS에서 소개하는 SSR 방식의 흐름은 위의 그림과 같습니다. SSR 방식으로 동작하기 위해서는 스크립트를 실행해야 하므로 Gatsby Cloud와 같은 <strong>Cloud Worker 시스템이 추가로 필요</strong>한 것을 확인할 수 있습니다.</p>\n<p>GatsbyJS에서 SSR 방식을 사용하기 위해서는 비동기 <code class=\"language-text\">getServerData</code> 함수를 사용해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">SSRPage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> serverData <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>main<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span><span class=\"token constant\">SSR</span> Page <span class=\"token keyword\">with</span> Dogs<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>img alt<span class=\"token operator\">=</span><span class=\"token string\">\"Happy dog\"</span> src<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>serverData<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>main<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> SSRPage<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getServerData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">https://dog.ceo/api/breeds/image/random</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>res<span class=\"token punctuation\">.</span>ok<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Response failed</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> props<span class=\"token operator\">:</span> <span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token number\">500</span><span class=\"token punctuation\">,</span> headers<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>서버에서 페이지를 구성하기 위한 스크립트를 <code class=\"language-text\">getServerData</code> 함수에서 작성해 반환하여 페이지 컴포넌트에서 <code class=\"language-text\">serverData</code> 속성으로 가져와 사용할 수 있습니다.</p>\n<blockquote>\n<p>GatsbyJS의 SSR 방식에 대한 자세한 내용은 <a href=\"https://www.gatsbyjs.com/docs/how-to/rendering-options/using-server-side-rendering/\">여기</a>에서 확인할 수 있습니다.</p>\n</blockquote>\n<p>다음으로는 SSR 방식과 같이 GatsbyJS v4에서 새롭게 추가된 <strong>D</strong>eferred <strong>S</strong>tatic <strong>G</strong>eneration (DSG) 방식에 대해서 알아보도록 하겠습니다.</p>\n<h3 id=\"deferred-static-generation-dsg\" style=\"position:relative;\"><a href=\"#deferred-static-generation-dsg\" aria-label=\"deferred static generation dsg permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>D</strong>eferred <strong>S</strong>tatic <strong>G</strong>eneration (DSG)</h3>\n<p>GatsbyJS의 기본 렌더링 방식인 <strong>SSG 방식은 CSR 방식에 비해 빠른 웹사이트 경험을 제공하지만, 빌드 시간이 오래 걸린다는 단점</strong>이 존재합니다. <strong>D</strong>eferred <strong>S</strong>tatic <strong>G</strong>eneration(DSG) 방식은 SSG 방식의 이런 단점을 개선합니다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 49.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABNklEQVQoz6VS7W6CQBD0/dMn4A36HiaN/0w0gihiyvGthPJlBGTqbHqKqT+aOsnmNscxuzO7E/xgGAb8F+N/J+OL4/EIx3EQBAHiOMZms4HnefB9H0opRFEkJ9+5rov9fo/z+fxAOhmzp2mK+XwO27ax2+2wWCxgWRa2263kvGewCM/VaoW6rnWfQiod9n2PV5CoL3Rtf5fMLiirqipkWSaSiMvlIlXHQbRte32T4XBIcYhzvL99IIvKOyE7JNF6vYZpmgjDUCQvl0vo7zqIPM/lHT1WnoL6DK5eto8e0ovZbCYeMk+SRIowZ9D80+mEruukoGEYmE6noqKqSrm/EergZCmXknSQiFZwoiTilJumkbwsy1/r87A2JNCVxmBnJORZFIVI1/7q/29r82w5nw3iL0tNfAMwHwNDa8rfNQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"6 deferred static generation\" title=\"6 deferred static generation\" src=\"/static/4151f10605b83c2b58b48a8b495dba1d/0a47e/6-deferred-static-generation.png\" srcset=\"/static/4151f10605b83c2b58b48a8b495dba1d/8a4e8/6-deferred-static-generation.png 150w,\n/static/4151f10605b83c2b58b48a8b495dba1d/5a46d/6-deferred-static-generation.png 300w,\n/static/4151f10605b83c2b58b48a8b495dba1d/0a47e/6-deferred-static-generation.png 600w,\n/static/4151f10605b83c2b58b48a8b495dba1d/1cfc2/6-deferred-static-generation.png 900w,\n/static/4151f10605b83c2b58b48a8b495dba1d/c1b63/6-deferred-static-generation.png 1200w,\n/static/4151f10605b83c2b58b48a8b495dba1d/da952/6-deferred-static-generation.png 1872w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<p>DSG 방식을 이용하면 특정 페이지의 <strong>빌드 시점을 지연(defer)</strong>시킬 수 있습니다. 이러한 방식은 처음으로 페이지를 방문하는 사용자의 브라우저에서 빌드가 진행됩니다. 이 사용자에게는 로딩 시간이 길 수 있지만, 이어지는 사용자에게는 SSG 방식과 동일하게 페이지가 제공됩니다. DSG 방식을 사용한 페이지의 요청은 SSG 방식과 동일하게 <strong>CDN을 이용해 제공</strong>될 수 있지만 SSG 방식과 다르게 서버를 초기 빌드 후에도 계속 켜두어야 합니다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 39.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAQFBv/EABcBAAMBAAAAAAAAAAAAAAAAAAECAwX/2gAMAwEAAhADEAAAAb2MF88LaH//xAAXEAADAQAAAAAAAAAAAAAAAAAAAzNB/9oACAEBAAEFAsfA/8QAFxEAAwEAAAAAAAAAAAAAAAAAAQIQMf/aAAgBAwEBPwFdE//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ASf/xAAWEAADAAAAAAAAAAAAAAAAAAAAAhD/2gAIAQEABj8CHn//xAAYEAACAwAAAAAAAAAAAAAAAAAAkQERUf/aAAgBAQABPyFCCi8P/9oADAMBAAIAAwAAABCAD//EABURAQEAAAAAAAAAAAAAAAAAABCh/9oACAEDAQE/ELj/xAAWEQADAAAAAAAAAAAAAAAAAAABEDH/2gAIAQIBAT8QoL//xAAbEAEBAAEFAAAAAAAAAAAAAAABEQAhMVFxkf/aAAgBAQABPxBon2FmSXktkupi7uDvP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"7 deferred static generation\" title=\"7 deferred static generation\" src=\"/static/73b73a56f8b568ac321139bf7072f81a/b4294/7-deferred-static-generation.jpg\" srcset=\"/static/73b73a56f8b568ac321139bf7072f81a/75985/7-deferred-static-generation.jpg 150w,\n/static/73b73a56f8b568ac321139bf7072f81a/f93b5/7-deferred-static-generation.jpg 300w,\n/static/73b73a56f8b568ac321139bf7072f81a/b4294/7-deferred-static-generation.jpg 600w,\n/static/73b73a56f8b568ac321139bf7072f81a/8e1fc/7-deferred-static-generation.jpg 900w,\n/static/73b73a56f8b568ac321139bf7072f81a/e5166/7-deferred-static-generation.jpg 1200w,\n/static/73b73a56f8b568ac321139bf7072f81a/c0b59/7-deferred-static-generation.jpg 1438w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<p>GatsbyJS에서 소개하는 DSG 방식의 흐름은 위의 그림과 같습니다. DSG 방식으로 동작하기 위해서는 SSR 방식과 동일하게 Gatsby Cloud와 같은 <strong>Cloud Worker 시스템이 추가로 필요</strong>합니다.</p>\n<p>GatsbyJS에서 DSG 방식을 사용하기 위해서는 Gatsby Node API의 <code class=\"language-text\">createPage</code> 함수의 인자 객체에 <code class=\"language-text\">defer: true</code> 값을 추가해주면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token function\">createPage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  path<span class=\"token operator\">:</span> <span class=\"token string\">'page-path'</span><span class=\"token punctuation\">,</span>\n  component<span class=\"token operator\">:</span> <span class=\"token string\">'component-path'</span><span class=\"token punctuation\">,</span>\n  context<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  defer<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<blockquote>\n<p>GatsbyJS의 DSG 방식에 대한 자세한 내용은 <a href=\"https://www.gatsbyjs.com/docs/how-to/rendering-options/using-deferred-static-generation/\">여기</a>에서 확인할 수 있습니다.</p>\n</blockquote>\n<p>지금까지 GatsbyJS의 렌더링 방식에 대해서 알아보았습니다. 다음 섹션에서는 NextJS에서 이용하는 렌더링 방식에 대해서 알아보겠습니다.</p>\n<h2 id=\"nextjs의-렌더링-방식\" style=\"position:relative;\"><a href=\"#nextjs%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%B0%A9%EC%8B%9D\" aria-label=\"nextjs의 렌더링 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NextJS의 렌더링 방식</h2>\n<p>NextJS는 모든 페이지에 기본적으로 <strong>pre-rendering</strong>을 이용합니다. 이것은 NextJS가 CSR 방식처럼 사용자의 브라우저에서 JavaScript를 모두 실행하는 대신에 각각 페이지의 HTML을 미리 생성합니다.</p>\n<p>NextJS를 이용해 생성된 HTML은 페이지에 필요한 최소한의 JavaScript를 가지고 있습니다. 브라우저에서 페이지가 로딩되면 JavaScript 코드가 실행되어 페이지에서 상호작용을 할 수 있도록 만듭니다.</p>\n<blockquote>\n<p>NextJS의 이러한 과정을 <em>hydration</em>이라고 부릅니다.</p>\n</blockquote>\n<p>NextJS는 GatsbyJS와 같게 SSG, SSR 방식을 지원하지만, GatsbyJS에서 지원하지 않는 증분 정적 재생성(<strong>I</strong>ncremental <strong>S</strong>tatic <strong>R</strong>egeneration, ISR) 방식을 지원합니다. 이번 섹션에서는 NextJS에서 각각의 렌더링 방식을 이용하는 법을 살펴보겠습니다.</p>\n<h3 id=\"static-site-generation-ssg-1\" style=\"position:relative;\"><a href=\"#static-site-generation-ssg-1\" aria-label=\"static site generation ssg 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>S</strong>tatic <strong>S</strong>ite <strong>G</strong>eneration (SSG)</h3>\n<p>SSG 방식은 GatsbyJS와 동일하게 <strong>빌드 시점에 모든 페이지의 HTML을 생성</strong>하고 각 페이지를 요청할 때 <strong>재사용</strong>합니다. NextJS는 공식 문서에서도 CDN 캐싱과 같은 성능 향상의 이유로 SSR 방식보다 <strong>SSG 방식을 권장</strong>하고 있습니다.</p>\n<p>NextJS에서 SSG 방식을 이용하는 방법은 아래와 같이 두 가지가 존재합니다.</p>\n<ol>\n<li>페이지의 <strong>내용이 외부 데이터에 의존</strong>할 경우</li>\n</ol>\n<p>페이지의 내용이 외부 데이터에 의존할 경우 <code class=\"language-text\">getStaticProps</code> 함수를 이용할 수 있습니다.</p>\n<blockquote>\n<p><code class=\"language-text\">getStaticProps</code> 함수의 자세한 내용은 <a href=\"https://nextjs.org/docs/basic-features/data-fetching/get-static-props\">여기</a>에서 확인할 수 있습니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Blog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> posts <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 개별 페이지 렌더링</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getStaticProps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://.../posts'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> post<span class=\"token operator\">:</span> <span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ol start=\"2\">\n<li>페이지의 <strong>URL이 외부 데이터에 의존</strong>할 경우</li>\n</ol>\n<p>페이지의 URL이 외부 데이터에 의존할 경우 <code class=\"language-text\">getStaticPaths</code> 함수를 사용할 수 있습니다. <code class=\"language-text\">pages/posts/[id].js</code>와 같이 동적인 URL을 생성해야 할 경우가 포함됩니다.</p>\n<blockquote>\n<p><code class=\"language-text\">getStaticPaths</code> 함수의 자세한 내용은 <a href=\"https://nextjs.org/docs/basic-features/data-fetching/get-static-paths\">여기</a>에서 확인할 수 있습니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Post</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> post <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 개별 페이지 렌더링</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getStaticPaths</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://.../posts'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> posts <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> paths <span class=\"token operator\">=</span> posts<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>post <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    params<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> id<span class=\"token operator\">:</span> post<span class=\"token punctuation\">.</span>id <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> paths<span class=\"token punctuation\">,</span> fallback<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getStaticProps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> prarms <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">https://.../posts/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>params<span class=\"token punctuation\">.</span>id<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> post<span class=\"token operator\">:</span> <span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">getStaticPaths</code> 함수에서 외부 데이터를 호출해 <code class=\"language-text\">id</code>의 해당하는 값들을 <code class=\"language-text\">paths</code>에 담아 객체 형태로 전달합니다. <code class=\"language-text\">paths</code>에 포함된 페이지들은 빌드 시에 pre-rendering 되며 <code class=\"language-text\">fallback</code> 속성이 <code class=\"language-text\">false</code>이므로 다른 URL 들은 404를 반환합니다.</p>\n<p><code class=\"language-text\">getStaticProps</code>, <code class=\"language-text\">getStaticPaths</code> 함수는 <strong>빌드 시점에 호출</strong>되며 <strong>페이지 파일에서만</strong> 사용할 수 있습니다. 페이지 파일이 아닌 <code class=\"language-text\">_app</code>, <code class=\"language-text\">_document</code>, <code class=\"language-text\">_error</code>와 같은 파일에서는 사용할 수 없습니다.</p>\n<p>NextJS의 Link 컴포넌트 또한 최적화를 위해 페이지 데이터를 prefetch 합니다. 기본값은 <code class=\"language-text\">true</code>로 설정되어 있으며 GatsbyJS와 동일하게 SSG 방식을 사용한 페이지는 preload 됩니다. Link 컴포넌트에 대해서 자세한 내용은 <a href=\"https://nextjs.org/docs/api-reference/next/link\">여기</a>에서 확인할 수 있습니다.</p>\n<figure>\n  <img src=\"/32b21b196f2251f655fb5673d508e7ce/8-next-routing-optimization.gif\">\n  <figcaption>\n    NextJS가 라우팅 될 페이지의 데이터를 미리 가져오는 모습\n  </figcaption>\n</figure>\n<p>다음으로는 NextJS에서의 SSR 방식에 대해서 살펴보겠습니다.</p>\n<h3 id=\"server-side-rendering-ssr-1\" style=\"position:relative;\"><a href=\"#server-side-rendering-ssr-1\" aria-label=\"server side rendering ssr 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>S</strong>erver <strong>S</strong>ide <strong>R</strong>endering (SSR)</h3>\n<p>NextJS의 SSR 방식 또한 GatsbyJS와 동일하게 매 <strong>요청마다 HTML을 생성</strong>합니다. SSR 방식을 사용하기 위해서는 <code class=\"language-text\">getServerSideProps</code> 함수를 사용하면 됩니다.</p>\n<p><code class=\"language-text\">getStaticProps</code> 함수와의 차이점은 <code class=\"language-text\">getStaticProps</code> 함수는 빌드 시점에 한 번만 실행되지만 <code class=\"language-text\">getServerSideProps</code> 함수는 <strong>매 요청마다 실행</strong>됩니다.</p>\n<blockquote>\n<p><code class=\"language-text\">getServerSideProps</code> 함수의 자세한 내용은 <a href=\"https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props\">여기</a>에서 확인할 수 있습니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Post</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 개별 페이지 렌더링</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getServerSideProps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">https://.../data</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">getServerSideProps</code> 함수도 마찬가지로 <strong>페이지 파일에서만</strong> 사용할 수 있습니다.</p>\n<p>NextJS는 페이지 요청시 데이터를 가져와야만 렌더링을 할 수 있는 <strong>인증 헤더 또는 지역 정보가 필요한 경우같은 상황에서만 사용하기를 권장</strong>합니다. 페이지 요청 중에 데이터를 렌더링할 필요가 없는 경우에는 클라이언트에서 데이터를 가져오거나 <code class=\"language-text\">getStaticProps</code> 함수를 이용한 <strong>SSG 방식을 권장</strong>합니다.</p>\n<p>마지막으로 NextJS의 렌더링 방식인 증분 정적 재생성(<strong>I</strong>ncremental <strong>S</strong>tatic <strong>R</strong>egeneration, ISR) 방식을 살펴보도록 하겠습니다.</p>\n<h3 id=\"incremental-static-regeneration-isr\" style=\"position:relative;\"><a href=\"#incremental-static-regeneration-isr\" aria-label=\"incremental static regeneration isr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>I</strong>ncremental <strong>S</strong>tatic <strong>R</strong>egeneration (ISR)</h3>\n<p>증분 정적 재생성(<strong>I</strong>ncremental <strong>S</strong>tatic <strong>R</strong>egeneration, ISR) 방식은 <code class=\"language-text\">stale-while-revalidate</code> 캐싱 전략을 따르는 하이브리드 방식입니다. ISR 방식을 이용하면 애플리케이션 전체를 새로 빌드할 필요 없이 <strong>페이지 단위로 정적 생성</strong>을 할 수 있습니다.</p>\n<blockquote>\n<p>캐싱 전략의 자세한 내용은 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Cache-Control\">여기</a>에서 확인할 수 있습니다.</p>\n</blockquote>\n<p>ISR 방식을 이용하면 <strong>SSG 방식의 장점을 유지하면서 페이지를 쉽게 확장</strong>할 수 있습니다. ISR 방식을 이용하기 위해서는 SSG 방식에 사용되었던 <code class=\"language-text\">getStaticProps</code> 함수에 반환 값에 <code class=\"language-text\">revalidate</code> 값을 추가해주면 됩니다.</p>\n<blockquote>\n<p>NextJS의 ISR 방식에 대한 자세한 내용은 <a href=\"https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration\">여기</a>에서 확인할 수 있습니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Blog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> posts <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 개별 페이지 렌더링</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getStaticProps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://.../posts'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      post<span class=\"token operator\">:</span> <span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      revalidate<span class=\"token operator\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getStaticPaths</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://.../posts'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> posts <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> paths <span class=\"token operator\">=</span> posts<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>post <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    params<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> id<span class=\"token operator\">:</span> post<span class=\"token punctuation\">.</span>id <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> paths<span class=\"token punctuation\">,</span> fallback<span class=\"token operator\">:</span> <span class=\"token string\">'blocking'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 코드에서 <code class=\"language-text\">revalidate</code> 값을 10으로 설정했으므로 NextJS는 페이지 요청 후 10초가 지난 후에 새로운 요청이 들어오면 페이지를 다시 생성합니다.</p>\n<p>ISR 방식을 이용해 페이지를 재생성하는 중에는 기존에 캐싱 된 페이지를 보여줍니다. 페이지 재생성이 성공하면 NextJS는 캐싱 된 페이지를 유효하지 않도록 만들고 재생성된 페이지를 보여주고 재생성이 실패하면 기존에 캐싱 된 페이지가 계속 보입니다.</p>\n<p>GatsbyJS의 DSG 방식과의 차이점은 <strong>ISR 방식은 일정 간격으로 페이지를 재생성</strong>할 수 있다는 점이 있습니다. <strong>DSG 방식은 페이지의 생성을 지연</strong>시킬 뿐 한번 <strong>페이지가 생성되면 정적인 상태가 유지</strong>됩니다. DSG 방식은 페이지가 생성된 후 페이지 내용을 업데이트해야 하는 경우 빌드를 다시 실행해 캐싱된 페이지를 비활성화해야 합니다.</p>\n<blockquote>\n<p>GatsbyJS에서 소개하는 DSG 방식과 ISR 방식의 차이는 <a href=\"https://www.gatsbyjs.com/blog/deferred-static-generation-guide/\">여기</a>에서 확인할 수 있습니다.</p>\n</blockquote>\n<p>GatsbyJS의 DSG 방식과 NextJS의 ISR 방식은 서로 해결하려 하는 문제 또한 다릅니다. DSG 방식은 SSG 방식의 오랜 문제점이었던 <strong>오래 걸리는 빌드 시간을 해결</strong>할 수 있는 방식이며, ISR 방식은 SSG 방식의 장점을 유지하면서 <strong>빌드를 매번 해야 하는 단점을 해결</strong>할 수 있는 방식입니다.</p>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>최근 NextJS + Vercel과 관련된 환경 설정을 진행할 일이 있어 관련 내용을 찾아보던 중 처음 보는 렌더링 방식인 ISR 방식이 있어 이 글을 쓰기로 결심했습니다. 지금까지 회사 업무를 진행할 때는 대부분 GatsbyJS 기반의 SSG 방식을 이용했었습니다.</p>\n<p>GatsbyJS v4부터 SSG 방식이 아닌 SSR 방식, DSG 방식 같은 다른 렌더링 방식 또한 지원한다는 것을 알게 되었고 왜 새로운 방식들을 지원하게 되었는지 궁금해졌습니다. 또한 NextJS는 기존에 Vercel을 이용한 쉬운 환경 구성, 배포가 가능한 것을 알고 있었지만, GatsbyJS 또한 Gatsby Cloud라는 서비스가 출시되고 이것들이 어떤 연관성이 있는지 궁금했습니다.</p>\n<p>글을 작성하면서 스스로 생각해본 점은 DSG 방식이나 ISR 방식 모두 <strong>서버에서 특정 스크립트를 실행</strong>해 지연 생성이나 재생성 과정을 거쳐야 하므로 <a href=\"https://developer.mozilla.org/ko/docs/Web/API/Service_Worker_API\">서비스 워커</a>를 이용해야 하고 따라서 이런 <strong>기능들을 쉽게 이용할 수 있도록 자체 클라우드 서비스를 운영</strong>하게 되었다는 생각이 들었습니다.</p>\n<p>또한 최근 참가했던 <a href=\"https://2022.feconf.kr/\">Feconf 2022</a>에서도 Edge Computing과 관련된 발표를 듣고 처음에는 이런 기술들이 어떻게 이용될까 하는 궁금증이 있던 찰나에 <a href=\"https://nextjs.org/conf\">NextJS Conf 2022</a>에서도 Edge와 관련된 발표가 2개나 있는 것을 보고 궁금증이 더 커졌는데 왜 이런 키워드가 떠오르고 있는지 이 글을 작성하면서 조금이나마 이해가 된 것 같습니다.</p>\n<p>Prateek Surana가 작성한 <a href=\"https://prateeksurana.me/blog/future-of-rendering-in-react/\">The future of rendering in React</a> 글을 보면 <strong>스트리밍 SSR</strong>, <strong>서버 컴포넌트</strong>같이 미래의 React 렌더링 방식들 또한 <strong>서비스 워커가 필요할 것 같은 방향성</strong>을 띠고 있다는 생각이 들었습니다. 왜 사람들이 Edge 키워드에 주의를 기울이는지 조금이나마 이해할 수 있었고 관련된 내용도 찾아서 정리해봐야겠다고 생각할 수 있었습니다.</p>\n<p>잘못된 내용이 존재하거나 오탈자 수정이 필요한 경우 편하게 코멘트나, 이메일을 통해 전달해주시면 감사합니다.</p>\n<p>긴 글 끝까지 읽어주셔서 감사합니다. 🙇‍♂️</p>\n<p><strong>참고자료</strong></p>\n<ul>\n<li><a href=\"https://nextjs.org/docs/basic-features/pages#pre-rendering\">NextJS: Pre-rendering</a></li>\n<li><a href=\"https://nextjs.org/docs/basic-features/pages#server-side-rendering\">NextJS: Server-side Rendering</a></li>\n<li><a href=\"https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration\">NextJS: Incremental Static Regeneration</a></li>\n<li><a href=\"https://vercel.com/docs/concepts/incremental-static-regeneration/overview\">Vercel: Incremental Static Regeneration</a></li>\n<li><a href=\"https://v4.gatsbyjs.com/docs/conceptual/rendering-options/\">GatsbyJS: Rendering Options</a></li>\n<li><a href=\"https://www.gatsbyjs.com/docs/glossary/static-site-generator/\">GatsbyJS: Static Site Generator</a></li>\n<li><a href=\"https://www.gatsbyjs.com/docs/glossary/server-side-rendering/\">GatsbyJS: Server-Side Rendering</a></li>\n<li><a href=\"https://www.gatsbyjs.com/docs/how-to/rendering-options/using-server-side-rendering/\">GatsbyJS: Using Server-side Rendering (SSR)</a></li>\n<li><a href=\"https://www.gatsbyjs.com/docs/how-to/rendering-options/using-deferred-static-generation/\">GatsbyJS: Using Deferred Static Generation (DSG)</a></li>\n<li><a href=\"https://www.gatsbyjs.com/blog/deferred-static-generation-guide/\">GatsbyJS: A Guide To Deferred Static Generation</a></li>\n<li><a href=\"https://www.gatsbyjs.com/blog/whats-new-in-gatsby-4\">What’s New in Gatsby 4</a></li>\n<li><a href=\"https://www.gatsbyjs.com/blog/2019-04-02-behind-the-scenes-what-makes-gatsby-great/#why-server-side-render\">Behind the Scenes: What makes Gatsby Great</a></li>\n</ul>","frontmatter":{"title":"GatsbyJS와 NextJS로 알아보는 React 렌더링 방식","date":"October 26, 2022","thumbnail":{"childImageSharp":{"fixed":{"src":"/static/a5cfc76fe87cde122629ae3648e7b715/3b869/thumbnail.png"}}}}}},"pageContext":{"slug":"/React/react-rendering-with-gatsby-and-next/","previous":{"fields":{"slug":"/TypeScript/2022-05-10-fp-ts-funtional-design-7/"},"frontmatter":{"title":"함수형 디자인: 대수적 자료형","category":"TypeScript","draft":false}},"next":{"fields":{"slug":"/Retrospective/우당탕-3년-차-프론트엔드-개발자가-돌아보는-한해/"},"frontmatter":{"title":"우당탕 3년 차 프론트엔드 개발자가 돌아보는 한해","category":"Retrospective","draft":false}}}},"staticQueryHashes":["3001444076","3128451518"]}