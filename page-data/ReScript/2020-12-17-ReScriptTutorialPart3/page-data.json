{"componentChunkName":"component---src-templates-blog-post-js","path":"/ReScript/2020-12-17-ReScriptTutorialPart3","result":{"data":{"site":{"siteMetadata":{"title":"Minsu's Dev Log","author":"Minsu Kim","siteUrl":"https://alstn2468.github.io","comment":{"disqusShortName":"","utterances":"alstn2468/alstn2468.github.io"},"sponsor":{"buyMeACoffeeId":"eMLdEwU"}}},"markdownRemark":{"id":"5b92a754-595c-56f5-86d4-7052af47c961","excerpt":"본 포스트는 ReScript 공식문서를 스터디하며 정리한 포스트 입니다.\n포스트를 작성하며 작성한 코드는 여기에서 확인할 수 있습니다. ReScript의 Type ReScript의 타입 시스템은 아래와 같은 장점이 존재한다. 강하다 (Strong) ReScript에서 하나의 타입은 다른 타입으로 변경될 수 없다. JavaScript…","html":"<p>본 포스트는 <a href=\"https://rescript-lang.org/docs/latest/\">ReScript 공식문서</a>를 스터디하며 정리한 포스트 입니다.<br/>\n포스트를 작성하며 작성한 코드는 <a href=\"https://github.com/alstn2468/ReScript_Tutorial\">여기</a>에서 확인할 수 있습니다.</p>\n<h2 id=\"rescript의-type\" style=\"position:relative;\"><a href=\"#rescript%EC%9D%98-type\" aria-label=\"rescript의 type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ReScript의 Type</h2>\n<p>ReScript의 타입 시스템은 아래와 같은 장점이 존재한다.</p>\n<ul>\n<li><strong>강하다</strong> (Strong)</li>\n</ul>\n<p>ReScript에서 <strong>하나의 타입은 다른 타입으로 변경될 수 없다.</strong> JavaScript에서는 코드가 실행되는 런타임에서 작성된 변수들의 타입이 변경될 수 있다. 예를 들어 <code class=\"language-text\">number</code> 타입의 변수가 때때로 <code class=\"language-text\">string</code> 타입으로 변경될 수 있다. 타입의 변경은 좋지 않은 기능이며 타입의 변경은 코드를 읽거나 디버깅할 때 코드를 이해하기 어렵게 만든다.</p>\n<ul>\n<li><strong>정적이다</strong> (Static)</li>\n</ul>\n<p>ReScript의 타입들은 <strong>컴파일 이후에는 모두 사라져 런타임에서는 존재하지 않는다.</strong> 타입으로 인해 저하되는 성능 걱정을 할 필요가 없다. 런타임에는 타입에 대한 정보가 필요하지 않으며 모든 정보 특히나 모든 타입 오류를 컴파일 타임에 알려줍니다.</p>\n<ul>\n<li><strong>정확하다</strong> (Sound)</li>\n</ul>\n<p>이것은 JavaScript로 컴파일되는 다른 많은 타입 언어들과 비교할 때 큰 차별화 요소다. <strong>ReScript의 타입은 절대 틀리지 않을 것을 보장한다.</strong> 대부분 언어의 타입 시스템은 값의 타입을 추측하고 에디터에서 잘못된 타입을 표시한다. ReScript는 그렇게 동작하지 않는다. ReScript는 가끔 정확하지 않은 타입 시스템은 기대와 일치하지 않아 결국 위험할 수 있다고 믿는다.</p>\n<blockquote>\n<p>원문은 Sound라고 작성되어 있지만 설명의 맥락과 알맞는 뜻을 Sound에서 찾을 수 없어 “정확하다”라고 의역을 진행했습니다.</p>\n</blockquote>\n<ul>\n<li><strong>빠르다</strong> (Fast)</li>\n</ul>\n<p>많은 개발자들이 프로젝트의 빌드 시간 중 얼마나 많은 시간이 타입 검사에 소요되는지 과소평가한다. ReScript의 <strong>타입 검사는 가장 빠른 것 중 하나다.</strong></p>\n<ul>\n<li><strong>추론된다</strong> (Inferred)</li>\n</ul>\n<p>타입을 직접 적을 필요는 없다. ReScript에서는 <strong>값에 해당하는 타입을 추론할 수 있다.</strong> 프로그램의 모든 타입을 틀리지 않고 타입 주석없이 추론하여 신속하게 추론할 수 있다는 것이 신기할 수 있다. ReScript는 가능하며 ReScript에 오신것을 환영한다. =)</p>\n<h2 id=\"inference\" style=\"position:relative;\"><a href=\"#inference\" aria-label=\"inference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Inference</h2>\n<p>아래의 let binding은 어떠한 작성된 타입도 포함하지 않는다.</p>\n<ul>\n<li>ReScript 코드</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token keyword\">let</span> score <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n<span class=\"token keyword\">let</span> add <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> b</code></pre></div>\n<p>하지만 ReScript는 <code class=\"language-text\">score</code>가 <code class=\"language-text\">int</code> 타입이라는 것을 값인 <code class=\"language-text\">10</code>을 통해 판단한다. 이것을 <strong>추론</strong>(inference)라고 한다. 마찬가지로 <code class=\"language-text\">add</code>함수가 2개의 <code class=\"language-text\">int</code> 타입 인자를 받으며 <code class=\"language-text\">int</code> 타입을 반환한다는 것을 <code class=\"language-text\">+</code> 연산자가 <code class=\"language-text\">int</code> 타입끼리만 동작한다는 것으로 판단해 알고있다.</p>\n<h2 id=\"type-annotation\" style=\"position:relative;\"><a href=\"#type-annotation\" aria-label=\"type annotation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Annotation</h2>\n<p>타입은 추론할 수 있지만 선택적으로 타입 주석을 통해 타입을 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token keyword\">let</span> score<span class=\"token punctuation\">:</span> int <span class=\"token operator\">=</span> <span class=\"token number\">10</span></code></pre></div>\n<p>만약 <code class=\"language-text\">score</code>에 대한 타입 주석의 해당 타입의 추론된 타입과 일치하지 않을 경우 컴파일 타임에서 오류가 발생한다. 다른 언어들과 달리 ReScript는 사용자가 작성한 타입 수적이 정확하다고 가정하지 않는다.</p>\n<p>또한 괄호를 이용해 표현식을 묶고 타입 주석을 작성할 수도 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token keyword\">let</span> myInt <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\n<span class=\"token keyword\">let</span> myInt<span class=\"token punctuation\">:</span> int <span class=\"token operator\">=</span> <span class=\"token number\">5</span>\n<span class=\"token keyword\">let</span> myInt <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">:</span> int<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">:</span> int<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> add <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">:</span> int<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> int<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> int <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> y\n<span class=\"token keyword\">let</span> drawCircle <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">~</span>radius <span class=\"token keyword\">as</span> r<span class=\"token punctuation\">:</span> int<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> circleType <span class=\"token operator\">=></span> <span class=\"token comment\">/* code here */</span></code></pre></div>\n<p>마지막 줄의 <code class=\"language-text\">(~radius as r: int)</code>는 레이블이 지정된(labeled) 인자다. 자세한 내용은 <a href=\"https://rescript-lang.org/docs/manual/latest/function\">함수 페이지</a>를 참조할 수 있다.</p>\n<h2 id=\"type-alias\" style=\"position:relative;\"><a href=\"#type-alias\" aria-label=\"type alias permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Alias</h2>\n<p>타입 별칭을 이용해 다른 이름으로 타입을 참조할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token keyword\">type</span> scoreType <span class=\"token operator\">=</span> int\n<span class=\"token keyword\">let</span> x<span class=\"token punctuation\">:</span> scoreType <span class=\"token operator\">=</span> <span class=\"token number\">10</span></code></pre></div>\n<p>위 코드의 <code class=\"language-text\">scoreType</code>은 <code class=\"language-text\">int</code> 타입과 동일하다.</p>\n<h2 id=\"type-parameter-aka-generic\" style=\"position:relative;\"><a href=\"#type-parameter-aka-generic\" aria-label=\"type parameter aka generic permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Parameter (aka Generic)</h2>\n<p>타입은 다른 언어들에서 제네릭과 유사한 매개변수들을 받을 수 있다. 매개변수의 이름은 <code class=\"language-text\">'</code>로 시작해야 한다. 매개변수화된 타입의 사용은 <strong>중복을 제거</strong>하는 것으로 중복 제거 이전의 코드는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token comment\">// 아래는 3가지 항목을 갖는 튜플이다.</span>\n<span class=\"token keyword\">type</span> intCoordinates <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>int<span class=\"token punctuation\">,</span> int<span class=\"token punctuation\">,</span> int<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">type</span> floatCoordinates <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>float<span class=\"token punctuation\">,</span> float<span class=\"token punctuation\">,</span> float<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">let</span> a<span class=\"token punctuation\">:</span> intCoordinates <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> b<span class=\"token punctuation\">:</span> floatCoordinates <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20.5</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>매개변수화된 타입인 <code class=\"language-text\">coordinates</code>를 사용해 아래와 같이 중복된 타입을 제거할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token keyword\">type</span> coordinates<span class=\"token operator\">&lt;</span><span class=\"token operator\">'</span>a<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">'</span>a<span class=\"token punctuation\">,</span> <span class=\"token operator\">'</span>a<span class=\"token punctuation\">,</span> <span class=\"token operator\">'</span>a<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">let</span> a<span class=\"token punctuation\">:</span> coordinates<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> b<span class=\"token punctuation\">:</span> coordinates<span class=\"token operator\">&lt;</span>float<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20.5</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위의 코드는 단지 설명을 위한 목적으로 만들어진 예제일 뿐이며 ReScript는 타입을 추론할 수 있으므로 아래와 같이 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token keyword\">let</span> buddy <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>타입 시스템은 <code class=\"language-text\">buddy</code>가 <code class=\"language-text\">(int, int, int)</code>임을 유추할 수 있으며 다른 것을 작성할 필요는 없다. 타입 인자는 많은 곳에 나타나며 ReScript의 배열은 <code class=\"language-text\">array&lt;'a></code>와 같이 타입 매개변수를 요구하는 타입이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token comment\">// `array&lt;string>`으로 추론된다.</span>\n<span class=\"token keyword\">let</span> greetings <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"world\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"how are you\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>타입이 매개변수를 받지 않는 경우 표준 라이브러리에서 지루하게 타입 <code class=\"language-text\">arrayOfString</code>, <code class=\"language-text\">arrayOfInt</code>, <code class=\"language-text\">arrayOfTuplesOfInt</code> 등을 정의해야 한다.</p>\n<p>타입은 많은 인자들을 받을 수 있으며 구성이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token keyword\">type</span> result<span class=\"token operator\">&lt;</span><span class=\"token operator\">'</span>a<span class=\"token punctuation\">,</span> <span class=\"token operator\">'</span>b<span class=\"token operator\">></span> <span class=\"token operator\">=</span>\n  <span class=\"token operator\">|</span> <span class=\"token constructor\">Ok</span><span class=\"token punctuation\">(</span><span class=\"token operator\">'</span>a<span class=\"token punctuation\">)</span>\n  <span class=\"token operator\">|</span> <span class=\"token constructor\">Error</span><span class=\"token punctuation\">(</span><span class=\"token operator\">'</span>b<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">type</span> myPayload <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> myPayloadResults<span class=\"token operator\">&lt;</span><span class=\"token operator\">'</span>errorType<span class=\"token operator\">></span> <span class=\"token operator\">=</span> array<span class=\"token operator\">&lt;</span>result<span class=\"token operator\">&lt;</span>myPayload<span class=\"token punctuation\">,</span> <span class=\"token operator\">'</span>errorType<span class=\"token operator\">></span><span class=\"token operator\">></span>\n\n<span class=\"token keyword\">let</span> payloadResults<span class=\"token punctuation\">:</span> myPayloadResults<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token constructor\">Ok</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">:</span> <span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constructor\">Ok</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">:</span> <span class=\"token string\">\"bye\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constructor\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Something wrong happened!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>위 코드에서 <code class=\"language-text\">result</code> 타입은 <code class=\"language-text\">Ok</code>에 전달되는 <code class=\"language-text\">a</code>타입과 <code class=\"language-text\">Error</code>에 전달되는 <code class=\"language-text\">b</code>타입을 타입 매개변수로 전달 받는다. <code class=\"language-text\">myPayloadResults</code>에 사용되는 <code class=\"language-text\">result</code>타입의 <code class=\"language-text\">a</code>타입에 전달되는 <code class=\"language-text\">myPayload</code>타입은 타입 별칭으로 작성되어 있으며 <code class=\"language-text\">myPayloadResults</code>타입은 <code class=\"language-text\">errorType</code>을 타입 매개변수로 전달받으며 전달받은 이 타입은 <code class=\"language-text\">result</code>의 <code class=\"language-text\">b</code>타입에 전달된다.</p>\n<h2 id=\"recursive-types\" style=\"position:relative;\"><a href=\"#recursive-types\" aria-label=\"recursive types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recursive Types</h2>\n<p>함수와 같이 타입도 <code class=\"language-text\">rec</code>를 사용해 스스로를 참조할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token keyword\">type</span> <span class=\"token keyword\">rec</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> string<span class=\"token punctuation\">,</span>\n  friends<span class=\"token punctuation\">:</span> array<span class=\"token operator\">&lt;</span>person<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">person</code>타입의 필드인 <code class=\"language-text\">friends</code>는 <code class=\"language-text\">array&lt;person></code>타입이며 <code class=\"language-text\">rec</code>을 이용해 자기 자신의 타입인 <code class=\"language-text\">person</code>타입을 참조할 수 있다.</p>\n<h2 id=\"mutually-recursive-types\" style=\"position:relative;\"><a href=\"#mutually-recursive-types\" aria-label=\"mutually recursive types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mutually Recursive Types</h2>\n<p>타입은 <code class=\"language-text\">and</code>를 이용해 상호 재귀적으로 사용할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token keyword\">type</span> <span class=\"token keyword\">rec</span> student <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>taughtBy<span class=\"token punctuation\">:</span> teacher<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">and</span> teacher <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>students<span class=\"token punctuation\">:</span> array<span class=\"token operator\">&lt;</span>student<span class=\"token operator\">></span><span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">student</code>타입은 <code class=\"language-text\">teacher</code>타입을 참조하며 <code class=\"language-text\">teacher</code>타입은 <code class=\"language-text\">array&lt;student></code>형태로 <code class=\"language-text\">student</code>를 참조한다.</p>\n<h2 id=\"type-escape-hatch\" style=\"position:relative;\"><a href=\"#type-escape-hatch\" aria-label=\"type escape hatch permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Escape Hatch</h2>\n<p>ReScript의 타입 시스템은 견고하며 암시적 타입 캐스팅, 임의의 값 타입 추측과 같은 위험하고 안전하지 않은 것들을 허용하지 않는다. 하지만 실용적으로 ReScript는 타입 시스템에게 거짓말을 할 수 있도록 하나의 탈출구를 노출한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token keyword\">external</span> myShadyConversion<span class=\"token punctuation\">:</span> myType1 <span class=\"token operator\">=></span> myType2 <span class=\"token operator\">=</span> <span class=\"token string\">\"%identity\"</span></code></pre></div>\n<p>위의 선언은 <code class=\"language-text\">myType1</code>을 <code class=\"language-text\">myType2</code>로 변환하며 아래와 같이 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"reason\"><pre class=\"language-reason\"><code class=\"language-reason\"><span class=\"token keyword\">external</span> convertToFloat <span class=\"token punctuation\">:</span> int <span class=\"token operator\">=></span> float <span class=\"token operator\">=</span> <span class=\"token string\">\"%identity\"</span>\n<span class=\"token keyword\">let</span> age <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n<span class=\"token keyword\">let</span> gpa <span class=\"token operator\">=</span> <span class=\"token number\">2.1</span> <span class=\"token operator\">+.</span> convertToFloat<span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span></code></pre></div>\n<p>이 기능은 남용하지 않는게 좋으며 지나치게 동적인 JavaScript 코드와 같이 사용해야 한다면 유용하게 사용할 수 있다. 자세한 enternal 기능들은 <a href=\"https://rescript-lang.org/docs/manual/latest/external\">여기</a>에서 확인할 수 있다.</p>\n<p>참고 : 이 특정 <code class=\"language-text\">external</code> 기능이 <code class=\"language-text\">@bs</code> 주석이 앞에 붙지않는 유일한 항목이다.</p>","frontmatter":{"title":"ReScript 공식문서로 ReScript 훑어보기 (3)","date":"December 17, 2020","thumbnail":null}}},"pageContext":{"slug":"/ReScript/2020-12-17-ReScriptTutorialPart3/","previous":{"fields":{"slug":"/ReScript/2020-12-16-ReScriptTutorialPart2/"},"frontmatter":{"title":"ReScript 공식문서로 ReScript 훑어보기 (2)","category":"ReScript","draft":false}},"next":{"fields":{"slug":"/ReScript/2020-12-19-ReScriptTutorialPart4/"},"frontmatter":{"title":"ReScript 공식문서로 ReScript 훑어보기 (4)","category":"ReScript","draft":false}}}},"staticQueryHashes":["3001444076","3128451518"]}