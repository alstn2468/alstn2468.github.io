{"componentChunkName":"component---src-templates-blog-post-js","path":"/TypeScript/2021-06-05-fp-ts-8","result":{"data":{"site":{"siteMetadata":{"title":"Minsu's Dev Log","author":"Minsu Kim","siteUrl":"https://alstn2468.github.io","comment":{"disqusShortName":"","utterances":"alstn2468/alstn2468.github.io"},"sponsor":{"buyMeACoffeeId":"eMLdEwU"}}},"markdownRemark":{"id":"04c8d2de-23f7-504e-add9-10291b1cf0f5","excerpt":"본 포스트는 fp-ts 공식 문서의 Learning Resources에 있는 Getting Started에서 소개하는 문서들을 번역하며 학습한 문서입니다. 원본 문서는 링크에서 확인할 수 있으며 작성한 코드들은 여기에서 확인할 수 있습니다. fp-ts 시작하기 (Monad) 지난 포스트에서 우리는 이 Applicative 인스턴스를 인정한다면 를 들어 올림으로써 순수한 항 프로그램 로 이펙트 있는 프로그램 를 구성할 수 있음을 보았습니다. 프로그램 f 프로그램 g…","html":"<p>본 포스트는 fp-ts 공식 문서의 <a href=\"https://gcanti.github.io/fp-ts/learning-resources/\">Learning Resources</a>에 있는 Getting Started에서 소개하는 문서들을 번역하며 학습한 문서입니다. 원본 문서는 <a href=\"https://dev.to/gcanti/getting-started-with-fp-ts-monad-6k\">링크</a>에서 확인할 수 있으며 작성한 코드들은 <a href=\"https://github.com/alstn2468/getting-started-fp-ts/tree/main/src/getting_started_series/8_monad\">여기</a>에서 확인할 수 있습니다.</p>\n<h2 id=\"fp-ts-시작하기-monad\" style=\"position:relative;\"><a href=\"#fp-ts-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-monad\" aria-label=\"fp ts 시작하기 monad permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>fp-ts 시작하기 (Monad)</h2>\n<p><a href=\"https://alstn2468.github.io/TypeScript/2021-05-01-fp-ts-6/\">지난 포스트</a>에서 우리는 <code class=\"language-text\">M</code>이 Applicative 인스턴스를 인정한다면 <code class=\"language-text\">g</code>를 들어 올림으로써 순수한 <code class=\"language-text\">n</code>항 프로그램 <code class=\"language-text\">g</code>로 이펙트 있는 프로그램 <code class=\"language-text\">f: (a: A) => M&lt;B></code>를 구성할 수 있음을 보았습니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">프로그램 f</th>\n<th align=\"center\">프로그램 g</th>\n<th align=\"center\">조합</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">순수한</td>\n<td align=\"center\">순수한</td>\n<td align=\"center\"><code class=\"language-text\">g ∘ f</code></td>\n</tr>\n<tr>\n<td align=\"center\">이펙트 있는</td>\n<td align=\"center\">순수한, <code class=\"language-text\">n</code>항</td>\n<td align=\"center\"><code class=\"language-text\">liftAn(g) ∘ f</code></td>\n</tr>\n</tbody>\n</table>\n<p>그러나 마지막 한 가지 경우를 해결해야 합니다. <strong>두 프로그램이 모두</strong> 이펙트가 있다면 어떻게 할 수 있을까요?</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">M</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span>\n<span class=\"token function-variable function\">g</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">M</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">C</span><span class=\"token operator\">></span></code></pre></div>\n<p>그런 <code class=\"language-text\">f</code>와 <code class=\"language-text\">g</code>의 “조합”은 무엇일까요?</p>\n<p>이 마지막 경우를 처리하기 위해서는 중첩된 컨텍스트로 끝나기 쉽기 때문에 <code class=\"language-text\">Functor</code>보다 더 강력한 것이 필요합니다.</p>\n<h2 id=\"문제-중첩된-컨텍스트\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%A4%91%EC%B2%A9%EB%90%9C-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8\" aria-label=\"문제 중첩된 컨텍스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제: 중첩된 컨텍스트</h2>\n<p>더 많은 것이 필요한 이유를 더 잘 설명하기 위해 몇 가지 예시를 살펴보겠습니다.</p>\n<h3 id=\"예시-code-classlanguage-textm--arraycode\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%8B%9C-code-classlanguage-textm--arraycode\" aria-label=\"예시 code classlanguage textm  arraycode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예시 (<code class=\"language-text\">M = Array</code>)</h3>\n<p>트위터 사용자의 팔로워를 검색하고 싶다고 가정해 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n  followers<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> getFollowers <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token operator\">=></span> user<span class=\"token punctuation\">.</span>followers<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> followersOfFollowers <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>User<span class=\"token operator\">>></span> <span class=\"token operator\">=></span>\n  <span class=\"token function\">getFollowers</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>getFollowers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>뭔가 잘못된 것이 있습니다. <code class=\"language-text\">followersOfFollowers</code> 함수의 반환 타입은 <code class=\"language-text\">Array&lt;Array&lt;User>></code>이지만 우리는 <code class=\"language-text\">Array&lt;User></code> 타입을 반환하기를 원합니다.</p>\n<p>우리는 중첩된 배열을 <strong>평평하게</strong> 만들어야 합니다.</p>\n<p><code class=\"language-text\">fp-ts</code>에서 제공하는 <code class=\"language-text\">flatten: &lt;A>(mma: Array&lt;Array&lt;A>>) => Array&lt;A></code> 함수를 사용하면 편리합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> flatten <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'fp-ts/lib/Array'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> followersOfFollowers <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token operator\">=></span>\n  <span class=\"token function\">flatten</span><span class=\"token punctuation\">(</span><span class=\"token function\">getFollowers</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>getFollowers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>좋습니다. 다른 데이터 구조는 어떨까요?</p>\n<h3 id=\"예시-code-classlanguage-textm--optioncode\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%8B%9C-code-classlanguage-textm--optioncode\" aria-label=\"예시 code classlanguage textm  optioncode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예시 (<code class=\"language-text\">M = Option</code>)</h3>\n<p>숫자 목록의 가장 앞의 데이터의 역수를 계산하고 싶다고 가정해 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Option<span class=\"token punctuation\">,</span> some<span class=\"token punctuation\">,</span> none<span class=\"token punctuation\">,</span> option <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'fp-ts/lib/Option'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> head <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'fp-ts/lib/Array'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> inverse <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> none <span class=\"token operator\">:</span> <span class=\"token function\">some</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">/</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> inverseHead <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>arr<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token operator\">&lt;</span>Option<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">>></span> <span class=\"token operator\">=></span>\n  option<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token function\">head</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> inverse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>다시 한번 발생했습니다. <code class=\"language-text\">inverseHead</code> 함수는 <code class=\"language-text\">Option&lt;Option&lt;number>></code> 타입을 반환하고 있지만 우리는 <code class=\"language-text\">Option&lt;number></code> 타입이 반환되기를 원합니다.</p>\n<p>우리는 중첩된 <code class=\"language-text\">Option</code>을 <strong>평평하게</strong> 만들어야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> isNone <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'fp-ts/lib/Option'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> flatten <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>mma<span class=\"token operator\">:</span> Option<span class=\"token operator\">&lt;</span>Option<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">>></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token operator\">=></span>\n  <span class=\"token function\">isNone</span><span class=\"token punctuation\">(</span>mma<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> none <span class=\"token operator\">:</span> mma<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> inverseHead <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>arr<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span> <span class=\"token operator\">=></span>\n  <span class=\"token function\">flatten</span><span class=\"token punctuation\">(</span>option<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token function\">head</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> inverse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>모든 <code class=\"language-text\">flatten</code> 함수들은 우연히 생긴 것이 아닙니다. 이것들은 모두 안에 함수형적인 패턴이 존재합니다.</p>\n<p>실제로 이러한 모든 타입 생성자(및 기타 많은 생성자)는 <strong>Monad 인스턴스</strong>를 허용하고 있습니다.</p>\n<blockquote>\n<p><code class=\"language-text\">flatten</code>은 Monad의 가장 고유한 기능입니다.</p>\n</blockquote>\n<p>그래서 Monad는 무엇인가요?</p>\n<p>아래 내용이 Monad가 자주 제시되는 방식입니다.</p>\n<h2 id=\"정의\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%9D%98\" aria-label=\"정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정의</h2>\n<p>Monad는 아래와 같이 세 가지로 정의됩니다.</p>\n<p>(1) <a href=\"https://alstn2468.github.io/TypeScript/2021-05-02-fp-ts-6/\">Functor</a> 인스턴스를 허용하는 타입 생성자 <code class=\"language-text\">M</code></p>\n<p>(2) 아래의 시그니처를 갖는 <code class=\"language-text\">of</code> 함수</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">of</span><span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">HKT</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">M</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token operator\">></span></code></pre></div>\n<p>(3) 아래 시그니처를 갖는 <code class=\"language-text\">flatMap</code> 함수</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\">flatMap<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">HKT</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">M</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ma<span class=\"token operator\">:</span> <span class=\"token constant\">HKT</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">M</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">HKT</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">M</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<p><code class=\"language-text\">HKT</code> 타입은 제네릭 타입 생성자를 나타내는 <code class=\"language-text\">fp-ts</code> 방식이며 <code class=\"language-text\">HKT&lt;M, X></code>는 타입 <code class=\"language-text\">X</code>에 적용된 타입 생성자 <code class=\"language-text\">M</code> (즉, <code class=\"language-text\">M&lt;X></code>)을 생각할 수 있습니다.</p>\n</blockquote>\n<p><code class=\"language-text\">of</code>와 <code class=\"language-text\">flatMap</code> 함수는 아래의 세 가지 조건을 만족해야 합니다.</p>\n<ul>\n<li><strong>왼쪽 항등식</strong>(Left identity): <code class=\"language-text\">flatMap(of) ∘ f = f</code></li>\n<li><strong>오른쪽 항등식</strong>(Right identity): <code class=\"language-text\">flatMap(f) ∘ of = f</code></li>\n<li><strong>결합 법칙</strong>(Associativity): <code class=\"language-text\">flatMap(h) ∘ (flatMap(g) ∘ f) = flatMap((flatMap(h) ∘ g)) ∘ f</code></li>\n</ul>\n<p>여기서 <code class=\"language-text\">f</code>, <code class=\"language-text\">g</code>, <code class=\"language-text\">h</code>는 모두 이펙트가 있는 함수이고 <code class=\"language-text\">∘</code>는 일반적인 함수 조합입니다.</p>\n<h2 id=\"좋습니다-그런데-왜\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%8A%B5%EB%8B%88%EB%8B%A4-%EA%B7%B8%EB%9F%B0%EB%8D%B0-%EC%99%9C\" aria-label=\"좋습니다 그런데 왜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋습니다. 그런데 왜?</h2>\n<p>이런 정의를 처음 보았을 때 첫 반응은 당황했습니다.</p>\n<p>아래의 모든 질문이 내 머릿속에서 맴돌고 있었습니다.</p>\n<ul>\n<li>왜 그 두 가지 특정한 기능을 하고 왜 그런 타입을 갖고 있나요?</li>\n<li>왜 이름이 “flatMap”일까요?</li>\n<li>왜 규칙들이 있고 그것들은 무엇을 의미할까요?</li>\n<li>하지만 무엇보다도 <code class=\"language-text\">flatten</code>은 어디에 있을까요?</li>\n</ul>\n<p>이 포스트에서는 각 질문에 대한 답변을 시도합니다.</p>\n<p>문제로 돌아가 보겠습니다. 두 개의 이펙트 있는 함수(<strong>Kleisli arrows</strong>라고도 함)의 조합은 무엇입니까?</p>\n<figure>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAtUlEQVQoz6WS3Q7CIAyF9/6vR6bowu3CDSSLFBgb6HHEKD/RC3tBQtuv7SkM9z9saF0ppe1lbTT7Y4x9eN/30zjyM5+uUxUKITDGLpxLKfuw915rHWPawoYpPkPLshhDqF53ToehtjEG4UoIsonIOdfXDEAphbZVN1zhbysWsHua76owRLGsWMDWWiS1a8eorf8Nr+sKEmeF3bAZIqzg2zvP82zLNWT9QohWZA2nnpjc/OcPewBMgIpjY+mWaQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"두 개의 Kleisli arrows의 조합은 무엇입니까?\" title=\"두 개의 Kleisli arrows의 조합은 무엇입니까?\" src=\"/static/46e6d0563a2bcacf3950d8524bd23041/0a47e/1.png\" srcset=\"/static/46e6d0563a2bcacf3950d8524bd23041/8a4e8/1.png 150w,\n/static/46e6d0563a2bcacf3950d8524bd23041/5a46d/1.png 300w,\n/static/46e6d0563a2bcacf3950d8524bd23041/0a47e/1.png 600w,\n/static/46e6d0563a2bcacf3950d8524bd23041/65654/1.png 872w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n  <figcaption>\n    두 개의 Kleisli arrows의 조합은 무엇입니까?\n  </figcaption>\n</figure>\n<p>나는 그것의 타입이 무엇인지조차 모릅니다.</p>\n<p>잠깐… 우리는 이미 조합에 관한 추상화를 만났습니다. <a href=\"https://alstn2468.github.io/TypeScript/2021-05-01-fp-ts-5/\">카테고리</a>에 관해 얘기한 것을 기억하고 있습니까?</p>\n<blockquote>\n<p>카테고리는 조합의 본질을 포착합니다.</p>\n</blockquote>\n<p>우리는 이 문제를 카테고리 문제로 바꿀 수 있습니다. Kleisli arrows의 조합 모델에 맞는 카테고리를 찾을 수 있습니까?</p>\n<h2 id=\"kleisli-카테고리\" style=\"position:relative;\"><a href=\"#kleisli-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC\" aria-label=\"kleisli 카테고리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Kleisli 카테고리</h2>\n<p>이펙트 있는 함수만 포함하는 카테고리 <em>K</em> (<strong>Kleisli 카테고리</strong>)를 구성해 보겠습니다.</p>\n<ul>\n<li><strong>객체</strong>는 <em>TS</em> 카테고리와 동일한 객체로 즉 모든 TypeScript 타입입니다.</li>\n<li><strong>형태</strong>는 아래와 같이 구성됩니다. <em>TS</em>에 Kleisli 화살표 <code class=\"language-text\">f: A ⟼ M&lt;B></code>가 있으면 <em>K</em>에서 화살표 <code class=\"language-text\">f': A ⟼ B</code>​를 그립니다.</li>\n</ul>\n<figure>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 82%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/ElEQVQoz7WT3W6EIBBGff9H3LZ3RnZddYN/KAjtWUi0CN2kSftdEGA888EwFp85GWPatr3ebsuyRAHnusej67pxHFkVZ849Bynl+1Mffd97xIXgtm2Xy1tZlvBsFqmttRZms/ac1jkMlTrOEsHruiql5nm2ntwNF69pmnD+vh/BYOTeY7t6KYdh2P0zzsE2vQUZV62zdS1ekByeo1L59PIHLIQg/SnW3O9VVWVf8SrEAWOb3lN7pTBfGqMzBfut/gd2Xtn9H+HQBq+ZCKZReScwxqZpqCelquuaOa/Fks5hyZzSMuch3A7zG9B9gQniIzLSVWTUsUavPyjYF3TmsaoXE6gNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"TS 카테고리 위, K 생성자 아래\" title=\"TS 카테고리 위, K 생성자 아래\" src=\"/static/db855921664f3ccda6fd5d15e89161d0/0a47e/2.png\" srcset=\"/static/db855921664f3ccda6fd5d15e89161d0/8a4e8/2.png 150w,\n/static/db855921664f3ccda6fd5d15e89161d0/5a46d/2.png 300w,\n/static/db855921664f3ccda6fd5d15e89161d0/0a47e/2.png 600w,\n/static/db855921664f3ccda6fd5d15e89161d0/9c177/2.png 880w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n  <figcaption>\n    <i>TS</i> 카테고리 위, <i>K</i> 생성자 아래\n  </figcaption>\n</figure>\n<p>그렇다면 <em>K</em>에서 <code class=\"language-text\">f'</code>와 <code class=\"language-text\">g'</code>의 조합은 아래 이미지에서 <code class=\"language-text\">h'</code>라고 표시된 점선 화살표입니다.</p>\n<figure>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 95.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAAsTAAALEwEAmpwYAAABH0lEQVQ4y9WS2W6EMAxF5/+/EgkIYZlC2MOS9mhcBTQTRpXal/oBBZNjm+t7+/xF3IJZY1qVZUmSWGvP+WVZkjjOtJ7nOQA753gWRZGmaaaUh8nv+04SuKqqMEwA9H0vVQQjtm0jaYy5HHscR25IVSZsGgOzrmvTNOTJ+NEC8DAMQsLQf5omzkzbtq2Ql4LRFhKMe3STDpSgIvyl2tzoug4Y0t+jEEkZ5N2q8jyHfBK8LMv7/eMHez5p8Acm+RcwIotIbKjretFse4TkkdP7dH/EAWut8R1b4RJm4sBu4zjG4TC81nWNw2SjURRxPmDpwzffyn3HMSHdmItC0zSH/1mcfA5rF39+9VlAMDriUP5FqVR84i6McKm2TOHe+ucLVVFi5b1ZnF0AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"TS 카테고리의 조합 위, K 생성자의 조합 아래\" title=\"TS 카테고리의 조합 위, K 생성자의 조합 아래\" src=\"/static/0b3857c6c57f0721016a93eea9ca8852/0a47e/3.png\" srcset=\"/static/0b3857c6c57f0721016a93eea9ca8852/8a4e8/3.png 150w,\n/static/0b3857c6c57f0721016a93eea9ca8852/5a46d/3.png 300w,\n/static/0b3857c6c57f0721016a93eea9ca8852/0a47e/3.png 600w,\n/static/0b3857c6c57f0721016a93eea9ca8852/9c177/3.png 880w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n  <figcaption>\n    <i>TS</i> 카테고리의 조합 위, <i>K</i> 생성자의 조합 아래\n  </figcaption>\n</figure>\n<p><code class=\"language-text\">h'</code>는 <code class=\"language-text\">A</code>에서 <code class=\"language-text\">C</code>로 이동하는 화살표이므로 <em>TS</em>에는 <code class=\"language-text\">A</code>에서 <code class=\"language-text\">M&lt;C></code>까지에 해당하는 함수 <code class=\"language-text\">h</code>가 있어야 합니다.</p>\n<p>따라서 <em>TS</em>에서 <code class=\"language-text\">f</code>와 <code class=\"language-text\">g</code>의 조합에 대한 좋은 후보는 여전히 <code class=\"language-text\">(a: A) => M &lt;C></code>의 시그니처를 가진 이펙트 있는 함수입니다.</p>\n<p>그러한 함수를 어떻게 구성 할 수 있을까요?</p>\n<h2 id=\"우리는-단계별로-조합을-구성합니다\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EB%A6%AC%EB%8A%94-%EB%8B%A8%EA%B3%84%EB%B3%84%EB%A1%9C-%EC%A1%B0%ED%95%A9%EC%9D%84-%EA%B5%AC%EC%84%B1%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-label=\"우리는 단계별로 조합을 구성합니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>우리는 단계별로 조합을 구성합니다.</h2>\n<p>Monad 정의의 요점(1)은 <code class=\"language-text\">M</code>이 Functor 인스턴스를 허용하므로 함수 <code class=\"language-text\">g: (b: B) => M&lt;C></code>를 함수 <code class=\"language-text\">lift(g): (mb: M&lt;B>) => M&lt;M&lt;C>></code>로 들어 올릴 수 있습니다. (여기서는 동의어 <code class=\"language-text\">map</code>을 사용하고 있습니다.)</p>\n<figure>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 74.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAABBElEQVQoz6WT627CMAyF+/7v2EkhG6UVvbhJ26w39q0W0CGgoPmHFUyOz/GJG53+EdHrV2uRLMvy45Hsm2YbPJ+Dc1kUcfyRJMnhkEgtbzCP4xhC1/ffxKuyi1+2GJ0hBPBUnHNlWXrvkRM9UcthGAZud113nbyu9/uvPM/naX7GDLJt22ma1k2d8xuyaYwxIvVaBVFVlbWfItVDMJbsjLHWNst7XIKxjTFpmjLzfTAiMUO9UVoqi9UBWvLDJRER2HRI9YkzGc+Ro+LXU0T6W+0BqVT98qB6xrPz215hf5j5GyTyaEHWS7S4cfvObuMtcwK7NKYRi0Fl+8PQdbkxluLmzv4Adg10eLCzeU4AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"flatMap은 여기서 유래된다.\" title=\"flatMap은 여기서 유래된다.\" src=\"/static/1a8345909b040a430113ab0b3e2252ec/0a47e/4.png\" srcset=\"/static/1a8345909b040a430113ab0b3e2252ec/8a4e8/4.png 150w,\n/static/1a8345909b040a430113ab0b3e2252ec/5a46d/4.png 300w,\n/static/1a8345909b040a430113ab0b3e2252ec/0a47e/4.png 600w,\n/static/1a8345909b040a430113ab0b3e2252ec/9c177/4.png 880w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n  <figcaption>\n    <code class=\"language-text\">flatMap</code>은 여기서 유래된다.\n  </figcaption>\n</figure>\n<p>그리고 이제 우리는 막혔습니다. <code class=\"language-text\">M&lt;M&lt;C>></code> 타입의 값을 <code class=\"language-text\">M&lt;C></code> 타입의 값으로 <strong>평평하게</strong> 만들 수 있는 Functor 인스턴스에 대한 기능이 없습니다. 추가적인 <strong>flatten</strong> 기능이 필요합니다.</p>\n<p>이러한 기능을 정의 할 수 있다면 찾고 있는 조합을 얻을 수 있습니다.</p>\n<center>\n<p><code class=\"language-text\">h = flatten ∘ map(g) ∘ f</code></p>\n</center>\n<p>하지만 <code class=\"language-text\">flatten ∘ map(g)</code>은 <strong>flatMap</strong>입니다. 이름은 여기에서 유래되었습니다!</p>\n<center>\n<p><code class=\"language-text\">h = flatMap(g) ∘ f</code></p>\n</center>\n<p>이제 “조합표”를 업데이트 할 수 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">프로그램 f</th>\n<th align=\"center\">프로그램 g</th>\n<th align=\"center\">조합</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">순수한</td>\n<td align=\"center\">순수한</td>\n<td align=\"center\"><code class=\"language-text\">g ∘ f</code></td>\n</tr>\n<tr>\n<td align=\"center\">이펙트 있는</td>\n<td align=\"center\">순수한, <code class=\"language-text\">n</code>항</td>\n<td align=\"center\"><code class=\"language-text\">liftAn(g) ∘ f</code></td>\n</tr>\n<tr>\n<td align=\"center\">이펙트 있는</td>\n<td align=\"center\">이펙트 있는</td>\n<td align=\"center\"><code class=\"language-text\">flatMap(g) ∘ f</code></td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">of</code>는 어떤가요? <code class=\"language-text\">of</code>는 <em>K</em>의 항등성 형태에서 유래됩니다. <em>K</em>의 각 항등성 형태에 대해 <code class=\"language-text\">A</code>에서 <code class=\"language-text\">M&lt;A></code>까지에 해당하는 함수가 있어야 합니다 (즉, <code class=\"language-text\">of: &lt;A>(a: A) => M&lt;A></code>)</p>\n<figure>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 138%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAIAAADuuAg3AAAACXBIWXMAAAsTAAALEwEAmpwYAAABkklEQVQ4y+WU63KCMBCFef+n044jaot4wZEEFZKAICS0B4IRqaAdf3ZnYEKSj9092Y31/YZZcRyv12vG+G63K4qib19Zlnj7+z2hxHVXlNAKpoRMJhPf98fj8eVyGYZntg1Po9GH4zgVjEcpSQgxO/osy7IgOAghwjDUmytYSnk6hcPpISjOmJLqfD6Db3LW/zDfDy1JErMBf0nT9AmMSaUUBliCt3YIdzCMMYaUOnEiQ5zF73nOuazPxdIieZ4HGduagQnDCHJ0IsLMfD6PItYbNkguxEPx4dlk0cCIxCzHtQ3I3oW1Zz3Qa2U/3FUbhwFtIVue508P3EjYwIfjEfxAbbeSEpQGNzhL0+l0+hTT+q1W7pezvJVnWduLbVhVznWz9VY//xO4Le3bnmVtLwIoQd3nDYx6xoVWDkZoPtG8m83mBtddJKKoe42hWtU9D7cpupXzOE4aGFNBEOg2LI0phZs8r6vdzBWySOJ4u/X0JV3BaDHbnun7RVwN4yiKqpBaRin9XCycpXtX20aDPx3VD1jNcyxRxG6+AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"of는 여기서 유래된다.\" title=\"of는 여기서 유래된다.\" src=\"/static/2de65e173c0828bf6cf08962cde601e9/0a47e/5.png\" srcset=\"/static/2de65e173c0828bf6cf08962cde601e9/8a4e8/5.png 150w,\n/static/2de65e173c0828bf6cf08962cde601e9/5a46d/5.png 300w,\n/static/2de65e173c0828bf6cf08962cde601e9/0a47e/5.png 600w,\n/static/2de65e173c0828bf6cf08962cde601e9/ace37/5.png 666w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n  <figcaption>\n    <code class=\"language-text\">of</code>는 여기서 유래된다.\n  </figcaption>\n</figure>\n<h2 id=\"법칙\" style=\"position:relative;\"><a href=\"#%EB%B2%95%EC%B9%99\" aria-label=\"법칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>법칙</h2>\n<p>마지막 질문: 법칙은 어디에서 왔습니까? 그것들은 <em>TS</em>로 번역된 <em>K</em>의 카테고리 법칙일 뿐입니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">법칙</th>\n<th align=\"left\"><strong><em>K</em></strong></th>\n<th align=\"left\"><strong><em>TS</em></strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">왼쪽 항등식 (Left identity)</td>\n<td align=\"left\"><code class=\"language-text\">1<sub>B</sub> ∘ f’ = f’</code></td>\n<td align=\"left\"><code class=\"language-text\">flatMap(of) ∘ f = f</code></td>\n</tr>\n<tr>\n<td align=\"left\">오른쪽 항등식 (Right identity)</td>\n<td align=\"left\"><code class=\"language-text\">f' ∘ 1A = f'</code></td>\n<td align=\"left\"><code class=\"language-text\">flatMap(f) ∘ of = f</code></td>\n</tr>\n<tr>\n<td align=\"left\">결합 법칙 (Associativity )</td>\n<td align=\"left\"><code class=\"language-text\">h' ∘ (g' ∘ f') = (h' ∘ g') ∘ f'</code></td>\n<td align=\"left\"><code class=\"language-text\">flatMap(h) ∘ (flatMap(g) ∘ f) = flatMap((flatMap(h) ∘ g)) ∘ f</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"code-classlanguage-textfp-tscode의-monad\" style=\"position:relative;\"><a href=\"#code-classlanguage-textfp-tscode%EC%9D%98-monad\" aria-label=\"code classlanguage textfp tscode의 monad permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">fp-ts</code>의 Monad</h2>\n<p><code class=\"language-text\">fp-ts</code>에서 <code class=\"language-text\">flatMap</code> 함수는 <code class=\"language-text\">chain</code>이라는 변형에 의해 모델링 되며, 기본적으로 인수가 재배열 된 <code class=\"language-text\">flatMap</code> 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\">flatMap<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">HKT</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">M</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ma<span class=\"token operator\">:</span> <span class=\"token constant\">HKT</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">M</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">HKT</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">M</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span>\nchain<span class=\"token operator\">:</span>   <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>ma<span class=\"token operator\">:</span> <span class=\"token constant\">HKT</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">M</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">HKT</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">M</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">HKT</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">M</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></code></pre></div>\n<blockquote>\n<p>참고: <code class=\"language-text\">chain</code>은 <code class=\"language-text\">flatMap</code>에서 파생될 수 있으며 반대도 가능하다.</p>\n</blockquote>\n<p>이제 중첩된 컨텍스트의 문제를 보여주는 예제로 돌아가 <code class=\"language-text\">chain</code>을 사용하여 문제를 해결할 수 있습니다.</p>\n<blockquote>\n<p>원문에서는 <code class=\"language-text\">Option.chain</code>과 <code class=\"language-text\">Array</code>의 <code class=\"language-text\">chain</code>을 사용하라고 작성되어 있지만, 최신 버전의 fp-ts에서는 deprecated 되어 있으며 <a href=\"https://gcanti.github.io/fp-ts/modules/Array.ts.html#chain\"><code class=\"language-text\">arrayChain</code></a>과 <a href=\"https://gcanti.github.io/fp-ts/modules/Option.ts.html#chain\"><code class=\"language-text\">optionChain</code></a>을 사용하면 됩니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token keyword\">type</span> <span class=\"token punctuation\">{</span> Option <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'fp-ts/lib/Option'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> chain <span class=\"token keyword\">as</span> arrayChain<span class=\"token punctuation\">,</span> head <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'fp-ts/lib/Array'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> chain <span class=\"token keyword\">as</span> optionChain <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'fp-ts/lib/Option'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> followersOfFollowers <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token operator\">=></span>\n  <span class=\"token function\">arrayChain</span><span class=\"token punctuation\">(</span>getFollowers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token function\">getFollowers</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> headInverse <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>arr<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span> <span class=\"token operator\">=></span>\n  <span class=\"token function\">optionChain</span><span class=\"token punctuation\">(</span>inverse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token function\">head</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>함수형 프로그래밍은 이펙트로 함수를 조합하는 보편적인 방법을 제공합니다. Functor, Applicative Functor 및 Monad는 모두 다른 종류의 프로그램을 조합하기 위한 원칙적인 도구를 제공하는 추상화입니다.</p>\n<blockquote>\n<p>요약 : 함수형 프로그래밍은 <em>실제로</em> 조합에 관한 것입니다.</p>\n</blockquote>","frontmatter":{"title":"fp-ts로 Typescript 함수형 프로그래밍 시작하기 8 (Monad)","date":"June 05, 2021","thumbnail":null}}},"pageContext":{"slug":"/TypeScript/2021-06-05-fp-ts-8/","previous":{"fields":{"slug":"/TypeScript/2021-05-30-fp-ts-7/"},"frontmatter":{"title":"fp-ts로 Typescript 함수형 프로그래밍 시작하기 7 (Applicative)","category":"TypeScript","draft":false}},"next":{"fields":{"slug":"/TypeScript/2021-06-12-fp-ts-9/"},"frontmatter":{"title":"fp-ts로 Typescript 함수형 프로그래밍 시작하기 9 (Either vs Validation)","category":"TypeScript","draft":false}}}},"staticQueryHashes":["3001444076","3128451518"]}